<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C/C++程序设计 | Zian</title><meta name="keywords" content="C/C++"><meta name="author" content="Zian"><meta name="copyright" content="Zian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C/C++程序设计"><meta name="application-name" content="C/C++程序设计"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C/C++程序设计"><meta property="og:url" content="http://example.com/2024/10/04/c++/index.html"><meta property="og:site_name" content="Zian"><meta property="og:description" content="C&amp;#x2F;C++程序语言设计基础"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/src/images/pageCover/c++.webp"><meta property="article:author" content="Zian"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/src/images/pageCover/c++.webp"><meta name="description" content="C&amp;#x2F;C++程序语言设计基础"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/10/04/c++/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://www.zian-twikoo.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Zian","link":"链接: ","source":"来源: Zian","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Zian',
  title: 'C/C++程序设计',
  postAI: '',
  pageFillDescription: 'HelloWorld, 注释, 单行注释, 多行注释, 标识符, 数据类型, 整型, 浮点型, 布尔型, 字符型, 字符串型, 变量和常量, 变量, 常量, 转义字符, 控制台输入, 宏定义, 命名空间, 使用语法, using关键字, 运算符, 算术运算符, 赋值运算符, 关系运算符, 逻辑运算符, 位运算符, 三目运算符, 流程控制, 顺序结构, 分支结构, if-else, switch-case, 循环结构, while循环, do-while循环, for循环, 流程控制的关键字, 函数, 函数的定义, 函数的重载 OverLoad, 函数的递归, 调用其他文件中的函数, 指针与引用, 内存分析, 内存分区, 代码区, 全局区, 栈区, 堆区, 内存中的数据残留, 指针, 指针的定义, 空指针, 野指针, 常量指针, 指针常量, 引用, 引用的本质, 常量引用, 数组, 数组的定义, 数组的使用, 数组的内存分析, 数组的遍历, 下标遍历, 范围遍历, 数组的排序, 选择排序, 冒泡排序, 数组元素查找, 顺序查询法, 二分查询法, 数组的练习, 浅拷贝与深拷贝, 二维数组, 二维数组的介绍, 二维数组的定义, 二维数组的使用, 面向对象, 面向对象介绍, 面向对象与面向过程, 案例分析, 小明买电脑, 把大象装冰箱, 类与对象, 类的设计与对象的创建, 类的设计, 对象的创建, 成员访问, 自定义的数据类型(类), 类外和其他文件中实现类函数, 类外实现, 其他文件中实现, 静态, 静态属性, 静态函数, 构造与析构, 构造函数的介绍, 构造函数的定义, 构造函数的使用, explicit关键字, 构造函数注意事项, 构造函数初始化列表, 拷贝构造函数, 析构函数, 深拷贝与浅拷贝的问题, 浅拷贝案例, 深拷贝案例, this指针, this是什么, this不可省略的情况, 返回当前对象的函数, 空指针访问成员函数, 常函数与常对象, 什么是常函数, 常对象, 友元, 友元是什么, 全局函数做友元, 成员函数做友元, 类做友元, 运算符重载, 什么是运算符重载, 可重载的运算符, 运算符重载 +, 运算符重载 ++, 运算符重载 ltlt, 运算符重载 x3D, 封装, 继承, 程序中的继承, 继承的语法, 继承的三种方式, 公共继承, 保护继承, 私有继承, 继承中的构造和析构, 父类子类成员同名的情况, 多继承, 多继承语法, 菱形继承, 虚继承, 多态, 多态的基本概念, 什么是多态, 多态的分类, 对象转型, 虚函数, 多态案例, 未使用多态实现, 使用多态实现, 纯虚函数与抽象类, 纯虚函数与多继承, 虚析构函数, 结构体, 结构体的定义与使用, 结构体与类的区别, 模板, 模板的介绍, 函数模板, 函数模板的定义, 函数模板的使用, 函数模板案例, 函数模板与普通函数, 函数模板的局限性, 类模板, 类模板的定义, 类模板做函数参数, 类模板继承, 类模板中的成员函数创建时机, 类模板类外实现, 类模板头文件和原文件分离问题, 类模板遇到友元, STL标准模板库, STL概述, STL基本概念, STL六大组件简介, STL优点, STL三大组件, 容器, 算法, 迭代器, 常用容器, string容器, string容器基本概念, string容器常用操作, vector容器, vector容器基本概念, vector容器常用操作, vector迭代器, vector小案例, deque容器, deque容器基本概念, deque容器常用操作, deque小案例, stack容器, stack容器基本概念, stack容器常用操作, queue容器, queue容器基本概念, queue容器常用操作, list容器, list容器基本概念, list的迭代器, list容器常用操作, setx2Fmultiset容器, setx2Fmultiset容器基本概念, setx2Fmultiset容器常用操作, 对组, mapx2Fmultimap容器, mapx2Fmultimap基本概念, mapx2Fmultimap常用操作, multimap案例, 算法, 函数对象, 谓语, 内建函数对象, 函数对象适配器, 算法概述, 常用遍历算法, for_each遍历算法, transform算法, 常用查找算法, 常用排序算法, 常用拷贝和替换算法, 常用算数生成算法, 常用集合算法第一个程序打印输出引用头文件程序的入口主函数一个项目只能有一个主函数已经定义的命名空间可释放注释省略中的输出类换行函数可以释放缓存区注释单行注释以两个斜线开始斜线之后的内容都是注释的内容不会被编译多行注释以开始以结束中间的所有内容都是注释的内容可以换行内容不会被编译标识符标识符是由字母数字下划线组成的一个字符序列用来表示程序中的数据代表代表标识符的命名规范由字母数字下划线组成不能有其他的组成部分不能以数字开头需要以字母或者下划线组成不能与系统关键字重复区分大小写数据类型整型整型就是整数的类型描述的是整数数字数据类型关键字空间大小数据范围短整型字节整型字节长整型字节长长整型字节返回一个数据类型或者一个变量的空间占用大小浮点型浮点型就是小数的类型用来描述的是小数数字数据类型关键字空间大小精确范围单精度浮点型字节小数点后面位双精度浮点型字节小数点后面位布尔型用来描述非真即假非假及真的数据类型数据类型关键字空间大小值布尔型字节字符型用来描述一个文本内容中最小组成单位数据类型关键字空间大小值字符型字节单引号引起来的内容字符串型由若干个字符组成的一个有序的字符序列数据类型关键字空间大小值字符串型单引号引起来的内容变量和常量变量变化的量可以修改值定义变量的语法数据类型标识符变量名数据类型标识符值数据类型标识符值标识符值标识符值常量不变化的量不可以修改值定义常量的语法数据类型标识符变量名转义字符转义字符配合某些特殊字符使用使其变成普通字符输出配合某些特定的普通字符使用代表某些特殊含义制表符四个空格换行符回车符控制台输入读取控制台上输入的内容并且给某一个变量进行赋值输入空格空格输入回车回车输出都为输入缓冲区问题在控制台输入的内容都被暂存到了一个缓冲区中从缓冲区取数据给变量进行赋值遇到和空格会被忽略可使用来忽略缓冲区的内容忽略一位和空格参数是忽略个数忽略所有内容可以连续输入错误处理内部会维护一个状态来记录本次的读取操作是否正常读取状态正确值为否则为读取状态错误值为否则为如果被标记为状态则会影响后续的读取操作恢复状态清除错误状态请输入一个整型的数字若上面的输入错误使用清除的错误状态后面的输入才可以正常执行清空缓冲区内容也可以清除错误状态请输入一个整型的数字宏定义宏定义在文件的头部使用来定义一个标识符用来描述一个字符串这个字符串就成为宏定义使用时会自动替换为定义的值宏定义命名空间为了避免各种类库的命名的标识符冲突引入了关键字命名空间名字空间名称空间可以更好的控制标识符的作用域使用语法定义命名空间名使用命名空间名成员名定义一个命名空间命名空间可以嵌套命名空间的使用命名空间是开放的可以随时向一个命名空间添加成员命名空间中添加成员关键字直接引用指定的命名空间或指定空间的指定成员导入命名空间命名空间导入命名空间的成员命名空间成员引用命名空间引用命名空间中的成员注意事项如果引用的命名空间存在和当前的命名空间相同的成员默认使用当前的命名空间中的成员如果引用的多个命名空间中存在相同名字的成员且当前命名空间中没有这个成员此时出现二义性命名空间不能省略如果引用的命名空间存在和当前的命名空间相同的成员默认使用当前的命名空间中的成员使用当前命名空间的成员使用引用的命名空间则命名空间不能省略如果引用的多个命名空间中存在相同名字的成员且当前命名空间中没有这个成员报错不明确命名空间不能省略命名空间不能省略运算符算术运算符对数字类型整型浮点型字符型的数据进行运算运算符含义示例对两个数字进行相加的计算对两个数字进行相减的计算对两个数字进行相乘的计算对两个数字进行相除的计算对两个数字进行求模的计算求余数前自增先进行再进行运算后自增再进行运算先进行前自减先进行再进行运算后自增再进行运算先进行注意事项整型与整型计算的结果还是一个整型所以如果得到的结果是浮点型此时系统会将这个数字强制类型转换成整型的结果舍去小数点后面的所有数字只保留整数部分在进行计算的时候结果会进行类型提升将结果提升为取值氛围大的数据类型与的计算结果是与的计算结果是与的计算结果是与的计算结果是赋值运算符将等号右边的值赋给左边的变量下面表格的前提运算符示例运算结果关系运算符对两个变量进行大小关系的比较最后比较的结果一定是布尔类型的运算符示例运算结果逻辑运算符对两个布尔类型的变量进行的逻辑操作运算符描述示例与运算两边为真即为真任意一个为假结果即为假或运算两边为假即为假任意一个为真结果即为真非运算非真即假非假及真异或运算相同为假不同为真短路与左边的结果为假右边的表达式不参与运算短路或左边的结果为真右边的表达式不参与运算位运算符作用于两个整数数字的运算将参与运算的每一个数字计算出补码对补码中的每一位进行类似于逻辑运算的操作相当于相当于原码十进制数据的二进制表现形式最左边为符号位为正为负反码正数的反码是本身负数的反码在原码的基础上符号位不变数值取反变变补码正数的补码是本身负数的补码在反码的基础上运算符描述示例位与运算位或运算位异或运算按位取反运算位左移运算位右移运算三目运算符语法条件是一个类型的变量或者类型运算结果的表达式运算逻辑如果的值是三目运算符的结果取否则取已成年未成年已成年流程控制顺序结构代码从上往下依次执行输出分支结构程序在某一个节点遇到了多种执行的可能性根据条件选择一个分支继续执行语句可用于变量的区间范围进行判断根据结果选择分支继续执行条件判断条件判断结果为执行该括号内的代码条件判断条件判断结果为条件判断结果为执行该括号内的代码条件判断结果为执行该括号内的代码如果或或后面的括号中有且只有一条语句此时括号可以省略条件判断条件判断结果为执行该条语句条件判断条件判断结果为条件判断结果为执行该括号内的代码条件判断结果为执行该括号内的代码青少年成年人年龄错误青少年成年人年龄错误语句用于多重分支且条件判断是等值固定特定值判断的情况执行该代码段执行该代码段没有匹配的值则执行该代码段确定的字符或整数值值只能是字符或整数的字面量不能是变量值不允许重复表示跳出结束结束语句所有情况都不匹配执行该处的内容可以写在任意位置也可以省略不写春天夏天秋天冬天没有该季节输出春天语句中的的穿透性当的变量和某一个的值匹配上之后将会跳过后续的或者的匹配直接向后穿透为了避免的穿透性每一个和可以使用来跳出语句春天夏天秋天冬天没有该季节输出夏天秋天冬天没有该季节当然也可以利用的穿透性实现特定的功能春天夏天秋天冬天没有该季节输出夏天循环结构某段代码需要被重复执行多次并且遵循一定规律则使用循环结构循环条件表达式循环体条件表达式循环终止的判断条件语句结果为类型的表达式循环体行循环要执行的语句流程说明执行条件表达式也就是执行循环是否终止的判断条件表达式的值如果是则循环结束如果是循环继续执行执行循环语句大括号中的代码需要循环的代码回到第一步再次执行直到表达式的结果为循环才会结束注意事项循环本身没有循环变量的声明和初始化的部分应在循环前声明循环变量并赋值循环本身也没有控制循环终止的判断条件语句部分所以需要再循环体中增加相应的控制语句否则容易死循环循环变量声明和初始化循环条件循环体更新循环变量输出示例需要在控制台上输入一个整型数字如果用户在控制台上输入的不正确让用户重复输入直到输入正确为止请输入一个整数输入错误请重新输入循环循环体条件表达式流程说明先执行循环体中的语句执行条件表达式循环终止的条件判断语句结果如果为继续执行如果是则循环结束回到第一步再次执行直到条件表达式的结果为注意事项循环为先执行后判断先执行一次循环体中的代码然后再执行条件表达式所以循环至少执行一次其他特点跟循环一样初始化部分循环体循环变量更新循环条件循环循环起点循环条件循环步长循环体循环起点循环变量的初始化如循环条件循环终止的条件为布尔表达式如循环步长循环改变的控制条件语句如循环体循环要执行的语句表达式之间要用分号分隔流程说明第一步执行循环变量初始化语句循环起点第二步执行循环终止的判断条件表达式结果为继续执行第三步结果为结束循环第三步执行循环语句第四步执行循环步长也就是循环改变的控制条件语句使循环变量的值发生改变第五步回到第二步再次执行执行第二步到第五步直到第二步的循环条件的表达式结果为循环结束当前循环变量的值输出循环的小括号中每一个部分都可以省略不写但是分号不能省略流程控制的关键字用于终止某个语句块的执行如果是在循环中则是跳出所在的循环如果是在语句中则为跳出所在的语句输出跳过本次循环执行下一次循环如果有多次循环默认继续执行离自己最近的循环提前终止本次循环只能在循环语句中使用输出可以在任意的位置设置标签使用关键字可以直接跳转到指定的标签的位置继续执行输出函数函数是一个可以多次使用的功能代码块函数的定义函数的定义返回值类型函数名参数列表形参函数体返回值有返回值则必须返回没有则不用返回函数的调用函数名参数列表实参返回值表示函数执行的结果无返回值为有返回值就为对应的数据类型返回函数执行后的结果并结束函数的执行函数名遵循标识符的命名规则参数列表定义若干个参数的部分参数类型参数名参数类型参数名参数类型参数名函数体函数的功能实现部分取两数最大的值输出注意事项函数不能嵌套函数不调用函数就不会被执行函数定义写在方法前面但可以提前声明变量名函数的执行会压到栈中去执行先进先出先调用的函数在栈的底部存放而新调用的函数会在栈的顶部存放程序先处理栈顶的函数中的逻辑函数的调用如果函数定义有参数列表则调用时参数个数和参数类型必须一致调用时必须为每个参数赋值形参在定义函数的时候小括号中定义的参数由于这样的参数只有形式上的定义并没有具体的值因此被称为形式实参在调用函数的时候小括号中定义的参数由于这样的参数位形参提供了确切的值因此将这样的参数叫做实际参数传参在调用的函数的时候用实参给形参赋值这样的过程叫做传参参数可以使用来修饰表示参数的值不允许修改的在定义函数的时候可以给参数一个默认值但该参数要放到参数列表的末尾传参时可以赋值也可以不赋值函数的重载在一个类中的多个函数函数名相同参数列表不同类型和数量不同则这两个函数就构成了重载关系调用的是调用的是调用的是函数的递归递归一种程序设计的思想在解决问题的时候可以将问题拆分成若干个小问题这些小问题的解决方式与大的问题解决方式相同通过解决这些小问题逐渐解决这个大问题由于涉及到方法的循环调用因此容易出现死递归的情况即所有的方法调用没有出口只能将方法压栈执行但是无法结束方法因此在使用递归的时候需要设置有效的出口条件避免无穷递归递进每一次推进计算都比上一次变得简单直至简单到无需继续推进就能获得结果也叫到达出口回归基于出口的结果逐层向上回归一次计算每一层的结果直至回归到最顶层计算一个数字的阶乘参数是需要计算阶乘的数字返回值是计算的结果出口条件递进计算的和调用其他文件中的函数文件中的内容是无法跨文件直接访问的若需要让某一个函数跨文件访问需要为其定义一个文件称为头文件在头文件中添加函数的声明部分即可需要使用的时候直接使用来包含指定的头文件即可完成文件文件头文件中只做声明不做实现文件导入系统头文件时用尖括号导入自定义头文件时只能用双引号输出输出指针与引用内存分析内存分区在程序执行的时候会在内存中开辟一些空间存储数据而内存又可以分为栈区堆区全局区代码区四个区代码区代码区存放程序编译之后生成的二进制代码例如我们写的函数就是存储在这函数在程序编译后存储于代码区调用函数时会压到栈区执行其中的代码全局区全局区内的变量在程序编译阶段已经分配好内存空间并初始化这块内存在程序的整个运行期间都会存在主要存放静态变量全局变量全局常量定义全局变量定义全局常量定义全局静态变量定义全局静态常量定义局部变量定义局部常量定义局部静态变量定义局部静态常量取地址符获取数据的内存地址全局区全局区全局区全局区栈区栈区全局区全局区栈区栈区由系统进行的内存管理主要存放函数的参数以及局部变量在函数完成执行系统会自动释放栈区的内存不需要用户管理堆区堆区就是通过分配的内存块由程序员手动申请手动释放若不手动释放程序结束后由系统回收生命周期是整个程序执行期间编译器不会负责它们的释放工作需要用程序区释放分配方式类似于数据结构中的链表内存泄漏通常说的就是堆区内存中的数据残留所谓的删除数据删除的只是你对指定地址范围空间的使用权你不能够再去使用这块空间了但是这块空间中原来的内容是不会被删除掉的指针定义变量就是在内存中开辟了一块指定大小的空间空间开辟的大小取决于不同的数据类型所占用的空间大小并且可以在这样的空间中进行值的赋值指针每一个开辟中的内存空间都是有一个唯一的地址的而这样的地址我们就称为是指针取地址操作符取出变量的内存地址间接寻址符返回变量所指定地址的变量的值指针的定义定义数据类型指针名声明了一个普通变量声明一个指针变量指向变量的地址通过取地址符获取的地址赋值给指针变量通过间接寻址符获取指针指向的内容指针的类型明明都是地址为什么区分指针类型因为不同类型的指针整数所跳过的字节数不同类型的指针是跳过四个字节类型的指针是跳过八个字节类型的指针是跳过一个字节指针整数是指针向前向后移动的大小指针指向变量类型大小整数指针指针结果是两个指针之间所隔的元素个数这种操作通常用于计算数组中两个元素之间的距离指针的作用就是通过地址取访问指针指向的变量指针的类型决定了指针解引用能够访问的字节数例如上面的类型的指针能访问四个字节类型的指针可以访问八个字节类型的指针能够访问一个字节空指针空指针指的是没有存储任何内存地址的指针变量一般使用来表示一个空的地址通常情况下使用空指针可以对指针变量进行初始化这里的指针变量没有存储任何的地址就是一个空指针设置为的指针变量存储的地址其实是但是地址到的内存为系统内存不允许访问因此这里会出现读取访问权限的问题野指针野指针指针中存储有一个内存地址但是这个地址指向的空间已经不存在了这样的指针称为野指针这里定义了一个指针变量随便写了一个地址这个地址对应的空间极有可能是不存在的访问野指针也是会出现问题的常量指针放在之前表示常量指针即常量的指针指针的指向是可以修改的但是不能通过指针来修改指向空间的值放在之前表示常量指针即常量的指针指针的指向是可以修改的但是不能通过指针来修改指向空间的值指针常量放在之后表示指针常量即指针是一个常量值可以通过指针来修改指向空间的值但是不能修改指针的地址指向放在之后表示指针常量即这个指针是一个常量可以通过指针修改指向空间的值但是指针的指向是不可以修改的引用变量名实质上是一段连续内存空间的别名引用可以作为一个已定义变量的别名通过这个别名和原来的名字都能够找到这份数据定义数据类型引用名输出输出输出注意事项在此不是求地址运算而是起标识作用类型标识符是指目标变量的类型引用必须在定义的同时初始化并且以后也要从一而终不能再引用其它数据有点类似于变量引用初始化之后不能改变不能有引用必须确保引用是和一块合法的存储单元关联可以建立对数组的引用引用的本质所谓的引用其实本质来讲就是一个指针常量定义一个整型的变量定义的引用这里相当于是这也就解释通了为什么和引用的同一块空间并且为什么不能修改引用在通过引用进行空间访问的时候系统会自动的转换成常量引用常量引用就是对一个常量建立引用又称为常引用主要用在函数的形参部分访问误操作导致在函数题中通过形参修改实参的值这里会出问题数组数组是一种线性数据结构其将相同类型的元素存储在连续的内存空间中我们将元素在数组中的位置称为该元素的索引数组是一个数据容器可以存储一个固定大小的相同类型元素的顺序集合特征数组可以用来存储任意数据类型的数据但是所有的数据需要是相同的数据类型数组是一个定长的容器一旦初始化完成长度将不能改变数组中的元素被存储在一段连续的内存空间中元素数组中存储的每一个数据称为数组中的元素长度数组的容量即数组中可以存储多少个元素遍历依次获取数组中的每一个元素数组的定义数据类型数组名数组长度数据类型数组名数组长度元素元素元素数据类型数组名元素元素元素定义指定长度的数组此时数组中填充的元素是不安全的定义指定长度的数组并使用默认的值来填充定义一个存储类型元素的数组填充个初始的值如果大括号中的初始的元素数量小于数组长度剩余的元素填充默认值定义一个数组指定数组中的元素此时数组的长度由初始元素的数量来决定数组的使用数组的访问为了能够区分数组中存储的每一个元素在数组中存储的每一个元素都有一个唯一的序号称为下标我们在访问数组中的元素的时候通过下标来访问注意事项数组中元素的下标是从开始的即数组中的元素下标范围是数组长度访问数组名下标修改数组名下标值返回一个对象或者类型所占的内存字节数注意事项通过下标访问数组元素的时候注意不要越界定义一个数组访问下标为的元素读取值并输出修改指定下标的元素的值数组长度的获取遍历数组并输出遍历到的元素数组的内存分析数组是一个容器在内存中进行空间开辟的时候并不是一个整体的空间而是开辟了若干个连续的空间例如这个数组的长度为存储的元素数据类型是也就是说需要在内存中开辟连续的个字节空间来存储元素表示的是数组中首元素的内存地址表示的是数组中首元素的内存地址可以直接通过来找到数组中的首元素后面一个元素可以通过的内存地址来访问到再后面的一个元素再加一个为什么要加呢因为这个数组中存储的元素类型是占据个字节空间如果是一个数组那就需要了将这一个元素的内存占用空间大小作为一个单位例如数组一个单位就是个字节数组一个单位就是个字节在进行元素访问的时候首元素直接通过就可以访问后面的一位元素偏移一个单位的地址个单位再后面的一位元素偏移两个单位的地址个单位再后面的一位元素偏移三个单位的地址个单位这就是为什么数组中元素的下标是从开始的注意事项当数组作为参数传递到一个函数中的时候传递的只是首元素的地址数组长度数组中第一个元素的地址数组中第二个元素的地址数组中第三个元素的地址数组中第四个元素的地址数组中第五个元素的地址数组中第六个元素的地址这里的参数其实等价于只是一个指向首元素的地址计算数组的长度因此需要在一个函数中完成数组的遍历排序等操作的时候需要带上长度数组的遍历下标遍历计算长度遍历范围遍历数组的排序选择排序开启一个循环每轮从未排序区间选择最小的元素将其放到已排序区间的末尾设数组的长度为初始状态下所有元素未排序即未排序索引区间为选取区间中的最小元素将其与索引处的元素交换完成后数组前个元素已排序选取区间中的最小元素将其与索引处的元素交换完成后数组前个元素已排序以此类推经过轮选择与交换后数组前个元素已排序仅剩的一个元素必定是最大元素无须排序因此数组排序完成设置最小值的下标找到最小值更新下标交换当前遍历的元素和记录的最小值下标位的元素定义一个数组计算数组长度选择排序输出排序之后的数组冒泡排序从数组最左端开始向右遍历依次比较相邻元素大小如果左元素右元素就交换二者遍历完成后最大的元素会被移动到数组的最右端设数组的长度为首先对个元素执行冒泡将数组的最大元素交换至正确位置接下来对剩余个元素执行冒泡将第二大元素交换至正确位置以此类推经过轮冒泡后前大的元素都被交换至正确位置仅剩的一个元素必定是最小元素无须排序因此数组排序完成比较相邻元素的大小相邻元素交换位置打印数组定义一个数组计算数组长度选择排序输出排序之后的数组数组元素查找数组元素查找指的是从给定的一个数组中查询指定元素出现的下标由于需要查询的元素在指定的数组中可能出现多次在这里我们只需要找到一个即可顺序查询法顺序查询就是从前往后遍历数组将数组中的每一个元素和需要查询的元素进行对比如果比较结果是相同的说明找到了需要查询的元素从一个数组中查询指定的元素出现的下标需要查询元素的数组数组的长度需要查找的元素元素存在的下标如果不存在这个元素返回遍历数组中的每一个元素定义一个数组计算数组长度从数组中查询元素二分查询法二分查询即利用数组中间的位置将数组分为前后两个子表如果中间位置记录的关键字大于查找关键字则进一步查找前一子表否则进一步查找后一子表重复以上过程直到找到满足条件的记录使查找成功或直到子表不存在为止此时查找不成功注意二分查询要求数组必须是排序的否则无法使用二分查询从一个数组中查询指定的元素出现的下标需要查询元素的数组升序排序的数组数组的长度需要查找的元素元素存在的下标如果不存在这个元素返回定义变量确定需要查询的范围计算出新的中间下标比较中间值和需要查询的元素中间值比要查询的元素大此情况说明在区间中中间值比要查询的元素小此情况说明在区间中找到目标元素返回其索引未找到目标元素返回定义一个数组计算数组长度从数组中查询元素数组的练习设计一个函数找出一个数组中最大的数字连同所在的下标一起输出空数组判断空数组不存在最大值不是空数组假设数组中第个元素就是最大的遍历数组依次和当前记录的最大值进行比较遍历到了新的最大值输出结果最大值是所在的下标是设计一个函数判断一个数组是不是一个升序的数组思路从前往后依次比较两个相邻的元素如果后面的元素比前面的小就可以说明不是升序递归如果位的元素大于等于位的元素并且前位的元素是升序的那么整体就是升序的设计一个函数找出一个整型数组中的第二大的值不可以通过排序实现不能修改数组中的数据顺序要考虑到最大的数字可能出现多次没有次大值定义两个变量分别用来记录最大值和次大值遍历数组中的每一个元素新的最大值出现了需要更新最大值和次大值新的次大值出现了设计一个函数将一个数组中的元素倒序排列注意不是降序交换第位和最后一位第一位和倒数第二位交换到一半即可将一个数组中的元素拷贝到另外一个数组中遍历原数组依次将元素拷贝到目标数组中越界判断设计一个函数比较两个数组中的元素是否相同数量每一个元素都相同才认为是相同的数组特殊判断逐个元素进行比较浅拷贝与深拷贝有时候我们对数组进行操作的时候需要进行数组的拷贝而此时会有浅拷贝和深拷贝两种数组的拷贝形式浅拷贝也就是地址拷贝拷贝到的是数组的首元素地址深拷贝定义一个新的数组长度与原来的数组相同将原来数组中的每一个元素依次拷贝到新的数组中从上述的说明中可以看出所谓的浅拷贝其实就是拷贝了一个地址得到的数组与原来的数组指向的其实是同一块空间因此对一个数组进行的操作都会对另外一个数组产生影响而深拷贝则不然深拷贝是创建了一个全新的数组虽然元素与原来的数组元素相同但是从内存上来看的话这是一个全新的数组修改这个数组不会对另外一个数组产生任何影响定义一个需要拷贝的数组浅拷贝地址拷贝深拷贝创建一个新的等长的数组并将元素依次拷贝过来二维数组二维数组的介绍数组其实就是一个容器存储着若干的数据数组中可以存储任意类型的元素可以存储整数可以存储浮点数字可以存储字符串其实数组中也可以存储一个数组如果一个数组中存储的元素类型是一个数组那么这样的数组就是二维数组理论上讲还有三维数组四维数组只不过一般不去讨论我们在讨论多维数组的时候基本也就是指的二维数组了二维数组的定义通常我们会将二维数组比作一个行列矩阵二维数组有多少元素相当于有多少行二维数组中的小一维数组有多少元素相当于有多少列二维数组的定义数据类型标识符行数列数数据类型标识符行数列数数据类型标识符行数列数数据类型标识符列数定义二维数组数据类型标识符行数列数数据类型标识符行数列数数据类型标识符行数列数此时系统会将这些元素中每个元素组合到一起最后剩余到不到个的元素补凑够位拼成一个数组数据类型标识符列数二维数组的使用二维数组中的元素访问与一维数组是相同的通过下标来进行访问即可输出面向对象面向对象介绍面向对象与面向过程面向过程是一种看待问题解决问题的思维方式着眼点在于问题是如何一步步的解决的然后亲力亲为的解决问题面向对象是一种看待问题解决问题的思维方式着眼点在于找到一个能够帮助解决问题的实体然后委托这个实体来解决问题案例分析小明买电脑面向过程小明去市场买配件小明将零件运回家里小明将电脑组装起来面向对象找到一个能够帮助买电脑的朋友老王委托老王去买电脑配件委托老王把电脑运回来委托老王把电脑组装起来把大象装冰箱面向过程我打开冰箱门我把大象装进冰箱我关上冰箱门面向对象冰箱开门大象进去冰箱里冰箱关门类与对象在面向对象的编程思想中着眼点在于找到一个能够帮助解决问题的实体然后委托这个实体解决问题在这里这个具有特定的功能能够解决特定问题的实体就是一个对象由若干个具有相同的特征和行为的对象的组成的集合就是一个类类是对象的集合对象是类的个体类的设计与对象的创建类的设计从若干个具有相同的特征和行为的对象中提取出这些相同的特征和行为设计为一个类类中定义所有的对象共有的特征和行为其中特征用属性表示行为用方法表示所谓属性其实就是定义在类中的一个变量类的定义类名权限修饰符成员变量成员变量成员变量权限修饰符成员函数成员函数成员函数设计一个类描述人属性姓名性别年龄方法走路吃饭人类会走路人类会吃饭注意事项在类中定义的属性方法默认都是的权限在类外是不能访问的如果需要在类外访问需要修改为权限在任意位置都可以访问在当前类和子类中可以访问只能在当前类中访问对象的创建直接创建对象隐式调用显式调用关键字在上述的三种创建方式中前两种方式是类似的我们在创建对象的时候区别主要是有没有使用关键字使用没有使用内存方面在堆空间开辟在栈空间开辟内存管理需要手动使用销毁不需要手动销毁属性初始化自动有默认的初始值没有初始值语法需要用类来接收变量不需要使用成员访问通过访问通过访问成员访问成员访问即访问类中的成员属性方法创建对象访问类中的属性访问类中的方法使用创建对象访问类中的属性访问类中的方法自定义的数据类型类我们在定义类中的属性的时候可以定义类型类型字符串类型等等那么能不能定义为另外的一个类的类型呢可以的类其实就是一种自定义的复杂的数据类型汪汪汪人类会走路人类会吃饭类外和其他文件中实现类函数类外实现在这里只是定义其他文件中实现如果我们设计的类需要在其他的文件中访问需要设计头文件静态我们在类中定义成员的时候函数属性可以使用关键字来修饰而这里的关键字表示的就是静态在一个类中被修饰的成员称为静态成员可以分为静态属性静态函数静态属性静态的属性内存是开辟在全局区的与对象无关并不隶属于对象在程序编译的时候就已经完成了空间的开辟与初始化的赋值操作了并且在程序运行的整个过程中是始终保持的静态属性的空间开辟早于对象的创建并且静态属性不隶属于对象而是被所有的对象所共享的因此如果你希望某一个属性是可以被所有的对象所共享的就可以设置为静态的属性静态的成员变量必须在类内定义类外初始化赋值静态的常量可以在类内定义并同时进行初始化也可以在类内定义类外进行初始化访问静态成员变量属性可以直接使用类来访问也可以通过对象来访问但是即便使用不同的对象访问到的空间仍然是相同的空间静态函数被关键字修饰的函数就是静态函数与静态属性类似静态函数依然不隶属于某一个对象而是隶属于当前类的静态的函数可以使用对象来调用也可以直接使用类来调用使用类来访问构造与析构构造函数的介绍构造函数是一个比较特殊的函数我们在使用一个类的对象的时候需要为其分配空间空间分配完成之后我们一般都会对创建的对象的属性进行初始化的操作而这个过程就可以在构造函数中来完成了因此构造函数是一个函数是在对象创建的时候触发用来对对象的属性进行初始化的赋值操作构造函数的定义构造函数的名字必须和类的名字相同构造函数不能写返回值类型构造函数可以有不同的重载这就是一个无参的构造函数无参构造函数执行了这就是一个有参的构造函数有参构造函数执行了参数构造函数的使用构造函数的定义构造函数没有返回值类型不能写连都不能写构造函数的名字必须与类名相同构造函数可以通过不同的参数来实现重载类的无参构造函数执行了类的有参构造函数执行了构造函数执行了构造函数的使用是在创建对象的时候调用的显式调用注意事项如果用这种缩写的方式切记如果使用无参构造函数的方式来创建对象不能添加隐式调用这里的大括号可以省略不写关键字提供了关键字禁止通过构造函数进行的隐式转换声明为的构造函数不能在隐式转换中使用用来修饰构造函数的修饰符表示无法通过隐式调用来访问这个构造函数这里创建对象会出错因为一个参数的构造函数已经被修饰为了不允许隐式转换构造函数注意事项如果在一个类中没有手动写任意的构造函数此时系统会自动为其提供一个权限的无参构造函数如果在一个类中写了任意的一个构造函数此时系统将不再提供默认的无参构造函数如果需要的话需要自己书写这样的对象创建会出错因为现在类中没有无参的构造函数构造函数初始化列表我们自己书写构造函数很大的一个用途就是对属性进行初始化的赋值操作就像如下代码的无参构造函数执行了希望给属性进行初始化的赋值操作的有参构造函数执行了希望给属性使用指定的值进行初始化在上述的代码中无论是无参的构造函数还是有参的构造函数我们的目的都是在创建对象的时候为属性进行初始化的赋值操作但是重复的这样的赋值有点麻烦此时为我们提供了初始化列表的方式来对属性进行初始化的赋值操作的无参构造函数执行了的有参构造函数执行了拷贝构造函数拷贝构造函数是中的另外一种构造函数这个构造函数也是可以由系统自动提供的如果我们没有给一个类写拷贝构造函数系统会自动的生成一个默认的拷贝构造函数为每一个属性进行赋值如果需要在拷贝构造函数中实现自己的拷贝逻辑需要自己书写拷贝构造函数系统默认的拷贝构造函数的无参构造函数执行了的有参构造函数执行了在上述的类中我们并没有去写拷贝构造函数此时系统会自动的提供一个拷贝构造函数实现对属性的赋值操作这里就是默认执行的拷贝构造函数相当于得到的对象的属性值与对象的属性值完全相同自己实现拷贝构造函数的无参构造函数执行了的有参构造函数执行了的拷贝构造函数执行了这里就是执行的拷贝构造函数相当于得到的对象的属性值与对象的属性值完全相同析构函数我们将一个对象从空间开辟开始到空间销毁结束这样的过程称为是一个对象的一生用生命周期来描述这样的过程对象的生命周期的起点是构造函数而对象的生命周期的终点就是析构函数析构函数将会在对象被销毁之前自动调用析构函数也是可以由系统自动生成的的无参构造函数执行了这就是的析构函数析构函数只能这样书写且不能有参数通常在析构函数中我们会进行一些资源的释放例如开辟的堆中的内存的析构函数执行了表示这个对象即将被销毁了释放对应的堆空间释放本来存储的地址防止野指针深拷贝与浅拷贝的问题深拷贝与浅拷贝是一个老生常谈的问题在数组的部分提到过在面向对象部分也有这两个概念在这里我们首先需要先区分一下什么是深拷贝什么是浅拷贝浅拷贝在拷贝构造函数中直接完成属性的赋值操作深拷贝在拷贝构造函数中创建一个新的空间使得属性中的指针指向这个新的空间浅拷贝案例的有参构造函数执行了拷贝构造函数拷贝构造函数的默认实现是直接进行属性值的拷贝析构函数执行了将指向的堆空间销毁创建一个对象通过拷贝构造函数拷贝出一个新的对象在刚才的拷贝构造函数中属性值直接进行值的拷贝这个过程就是一个浅拷贝对比两个对象的地址完全相同现在直接运行这个程序就会出问题了问题出现原因由于现在是浅拷贝的属性和的属性存储的地址是完全相同的函数执行结束都是局部变量需要销毁先销毁执行的析构函数此时指向的空间被销毁了再销毁执行的析构函数此时指向了一个已经被销毁了空间已经是一个野指针了会出现问题深拷贝案例的有参构造函数执行了拷贝构造函数拷贝构造函数的默认实现是直接进行属性值的拷贝这里不再是简简单单的值拷贝而是在堆上创建了一个新的空间新空间中存储原来的对应的值然后将这个新的空间地址给进行赋值析构函数执行了将指向的堆空间销毁创建一个对象通过拷贝构造函数拷贝出一个新的对象在刚才的拷贝构造函数中属性是开辟了一个新的空间的对比两个对象的地址不相同的对比两个对象的指向的值是相同的此时程序执行结束前指向的空间被销毁与指向的空间没有关系因此在进行空间销毁的时候也就不会有任何问题指针是什么在中是一个指针用来指向当前的对象的在上述代码中类中有一个函数可以返回属性的值那么问题来了一个类可以有多个对象的而非静态的属性是隶属于对象的不同的对象的在内存中的空间肯定也是不同的如何区分需要返回哪一个对象的呢在一个类中涉及到成员的访问的时候非静态的成员访问通常都会使用指针来访问这里使用指针来访问属性这种写法是默认的并且是可以省略不写的那么所谓的当前对象到底是谁呢最简单的理解就是哪个对象调用这个函数指针就指向谁不可省略的情况绝大多数的情况下在一个类的内部访问当前类中的非静态成员的时候指针都是可以省略不写的但是有一种情况指针不能省略必须要显式的写出来如果在一个函数中出现了与当前类的属性同名字的局部变量为了区分局部变量还是属性此时的指针不能省略在这个构造函数中出现了一个局部变量与属性名字相同了于是为了区分这两个需要使用指针显式的指向属性来进行访问返回当前对象的函数返回当前对象的引用是一个指针用来指向当前的对象因此如果需要返回当前的对象的话就需要使用来访问空指针访问成员函数在中使用空指针是可以访问成员函数的但是需要注意不能在函数中出现指针执行了是一个空指针执行了创建一个空对象函数访问可以正常访问因为在这个函数中没有使用到指针访问出问题因为在这个函数中使用到了指针访问出问题在这个函数中虽然没有写但是有属性的访问默认就是用到的常函数与常对象什么是常函数使用关键字修饰的函数叫做常函数常函数中不允许修改属性的值常函数中不允许调用其他的普通函数如果想要在常函数中修改某个属性的值需要将这个属性设置为修饰为可变的这个属性可以在常函数中进行修改定义常函数这里会出错不允许在常函数中修改普通属性的值这里会出错不允许在常函数中修改普通属性的值这里可以正常修改因此此时的已经被修饰为这里会出错不允许在常函数中调用其他的普通函数常对象在对象创建的时候使用修饰的对象就是常对象常对象可以访问任意的属性值但是不能修改普通属性的值常对象可以修改属性的值常对象只能调用常函数创建一个常对象使用这个常对象进行属性访问可以正常访问不能进行修改属性可以修改友元友元是什么类的主要特点之一是数据隐藏即类的私有成员无法在类的外部作用域之外访问但是有时候需要在类的外部访问类的私有成员怎么办解决方法是使用友元函数友元函数是一种特权函数允许这个特权函数访问私有成员程序员可以把一个全局函数某个类中的成员函数甚至整个类声明为友元全局函数做友元将全局函数作为友元这里是客厅这里是卧室可以访问公共部分可以访问私有部分创建对象成员函数做友元定义有这样一个类但是类中的成员是看不到的好基友我的家将基友的函数作为友元客厅卧室类做友元友元类友元类客厅卧室运算符重载什么是运算符重载运算符重载就是对已有的运算符重新进行定义赋予其另一种功能以适应不同的数据类型运算符重载只是一种语法上的方便也就是它只是另一种函数调用的方式在中可以定义一个处理类的新运算符这种定义很像一个普通的函数定义只是函数的名字由关键字及其紧跟的运算符组成差别仅此而已它像任何其他函数一样也是一个函数当编译器遇到适当的模式时就会调用这个函数语法定义重载的运算符就像定义函数只是该函数的名字是这里的代表了被重载的运算符函数的参数中参数个数取决于两个因素运算符是一元一个参数的还是二元两个参数运算符被定义为全局函数对于一元是一个参数对于二元是两个参数还是成员函数对于一元没有参数对于二元是一个参数此时该类的对象用作左耳参数注意有些人很容易滥用运算符重载它确实是一个有趣的工具但是应该注意它仅仅是一种语法上的方便而已是另外一种函数调用的方式从这个角度来看只有在能使涉及类的代码更易写尤其是更易读时请记住读代码的机会比我们写代码多多了才有理由重载运算符如果不是这样就改用其他更易用更易读的方式可重载的运算符几乎所有的运算符都可以重载但运算符重载的使用时相当受限制的特别是不能改变运算符优先级不能改变运算符的参数个数这样的限制有意义否则所有这些行为产生的运算符只会混淆而不是澄清语意可重载的运算符不可重载的运算符运算符重载定义属性定义构造函数用来初始化属性在类内实现的运算符重载全局函数实现运算符重载运算符重载定义属性定义构造函数用来初始化属性运算符前置先运算后取值在类内实现的运算符重载运算符后置先创建一个对象记录原来的值属性自增返回之前记录的值运算符重载定义属性定义构造函数用来初始化属性在类外定义运算符重载全局函数我希望在这里能够将类中的私有属性也拼接起来因此需要做成友元运算符重载拷贝构造函数执行了重载赋值运算符重载赋值运算符执行了析构函数执行了创建一个对象在这里虽然是等号运算符但是对象还没有完成空间开辟实例化那么在这里会调用拷贝构造函数而非重载的等号运算符修改的属性值这里的已经开辟空间了这里就会触发重载的等号运算符封装面向对象编程思想中有三大特性封装继承多态封装可以有广义和狭义上的概念广义上的封装我们可以将一些功能相近的一些类放入一个模块中这里我们更多强调的是狭义上的封装性定义我们可以通过对具体属性的封装实现把对成员变量的访问进行私有化让他只能在类内部可见通过公共的方法间接实现访问优点提高了代码的安全性复用性和可读性将不希望对外提供直接访问的属性封装起来继承程序中的继承在现实生活中我们与父母有继承的关系在中也存在继承的思想来提高代码的复用性代码的拓展性程序中的继承是类与类之间的特征和行为的一种赠予或获取一个类可以将自己的属性和方法赠予其他的类一个类也可以从其他的类中获取他们的属性和方法两个类之间的继承必须满足的关系两个类之间类将属性和特征赠予类此时类被称为是父类类被称为是子类两者之间的关系是子类继承自父类继承的语法在中在定义类的时候类名后面使用冒号来定义父类类中的所有成员都可以继承给子类但是私有的成员由于访问权限的限制子类无法访问一个类在继承了其他类之后也可以被其他类继承使用继承可以简化代码提高代码的复用性提高代码的拓展性最重要的是让类与类之间产生了继承关系是多态的前提继承的三种方式在中继承有三种方式分别是公共继承保护继承和私有继承其实只是一个访问权限的问题公共继承继承到父类中的属性保留原本的访问权限私有除外保护继承继承到父类中的属性超过权限的部分将降为权限私有除外私有继承继承到父类中的属性访问权限都为权限私有除外中默认使用的是私有继承公共继承定义类分别定义三种访问权限的属性定义自类公共继承继承到的还是权限继承到的还是权限是私有权限的无法继承给自类在类外依然可以访问类外不能访问因为这是保护权限保护继承定义类分别定义三种访问权限的属性定义自类保护继承继承到的原来是权限现在是权限继承到的还是权限是私有权限的无法继承给自类在类不能访问因为这是保护权限类外不能访问因为这是保护权限私有继承定义类分别定义三种访问权限的属性定义自类私有继承继承到的是私有权限继承到的是私有权限是私有权限的无法继承给自类类外不能访问因为这里是私有权限类外不能访问因为这里是私有权限继承中的构造和析构子类对象在创建的时候需要先调用父类中的构造函数用来初始化父类部分因此子类对象创建的时候先调用父类的构造函数再调用子类自己的构造函数而析构函数的调用正好相反先调用子类的析构函数再调用父类的析构函数父类中的无参构造函数调用了父类中的有参构造函数调用了父类中的析构函数调用了子类中的无参构造函数被调用了子类中的析构函数被调用了从上述的代码中可以看到子类对象在创建的时候需要先调用父类中的构造函数来构造父类部分这里默认是调用父类中的无参构造函数那么问题来了如果父类中没有无参构造函数或者父类中的无参构造函数是私有的怎么办父类中的有参构造函数调用了父类中的析构函数调用了子类中的无参构造函数被调用了子类中的析构函数被调用了父类子类成员同名的情况如果父类和子类中出现了同名字的成员属性函数子类会将从父类继承到的成员隐藏起来此时使用子类对象来访问的时候默认访问的是子类中的成员如果想要访问父类中的成员需要手动指定作用域父类中的函数被调用子类中的函数被调用默认调用的是子类中的函数如果想要调用父类中的函数需要显式调用默认访问自类中的属性如果想要调用父类中的属性需要显式调用多继承多继承语法我们可以从一个类继承我们也可以能同时从多个类继承这就是多继承但是由于多继承是非常受争议的从多个类继承可能会导致函数变量等同名导致较多的歧义多继承会带来一些二义性的问题如果两个基类中有同名的函数或者变量那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类继承的版本还是从基类继承的版本解决方法就是显示指定调用那个基类的版本派生类继承是从继承来的还是从继承来的解决歧义显示指定调用那个基类的菱形继承两个派生类继承同一个基类而又有某个类同时继承者两个派生类这种继承被称为菱形继承或者钻石型继承这种继承所带来的问题羊继承了动物的数据和函数鸵同样继承了动物的数据和函数当草泥马调用函数或者数据时就会产生二义性草泥马继承自动物的函数和数据继承了两份其实我们应该清楚这份数据我们只需要一份就可以对的访问不明确虚继承采用虚继承方式继承那么被称为虚基类通过虚继承解决了菱形继承所带来的二义性问题二义性问题解决输出结果多态多态的基本概念什么是多态生活中的多态是指的客观的事物在人脑中的主观体现例如在路上看到一只哈士奇你可以看做是哈士奇可以看做是狗也可以看做是动物主观意识上的类别与客观存在的事物存在的关系的时候即形成了多态在程序中一个类的引用指向另外一个类的对象从而产生多种形态当二者存在直接或者间接的继承关系时父类引用指向子类的对象即形成多态多态是面向对象三大特性之一记住继承是多态的前提如果类与类之间没有继承关系也不会存在多态多态的分类支持编译时多态静态多态和运行时多态动态多态运算符重载和函数重载就是编译时多态而派生类和虚函数实现运行时多态静态多态和动态多态的区别就是函数地址是早绑定静态联编还是晚绑定动态联编如果函数的调用在编译阶段就可以确定函数的调用地址并产生代码就是静态多态编译时多态就是说地址是早绑定的而如果函数的调用地址不能编译不能在编译期间确定而需要在运行时才能决定这这就属于晚绑定动态多态运行时多态对象转型对象可以作为自己的类或者作为它的基类的对象来使用还能通过基类的地址来操作它取一个对象的地址指针或引用并将其作为基类的地址来处理这种称为向上类型转换也就是说父类引用或指针可以指向子类对象通过父类指针或引用来操作子类对象父类的引用指向子类的对象向上转型后的对象调用父类中的函数虚函数上述代码的运行结果是说明执行的是父类中的函数而非子类中的函数于是现在就有一个问题出现了为什么的引用指向的实际上是一个对象但是为什么会调用父类中的函数实现呢解决这个问题我们需要了解下绑定捆绑概念把函数体与函数调用相联系称为绑定捆绑当绑定在程序运行之前由编译器和连接器完成时称为早绑定上面的问题就是由于早绑定引起的因为编译器在只有地址时并不知道要调用的正确函数编译是根据指向对象的指针或引用的类型来选择函数调用这个时候由于调用函数的时候使用的是类型编译器确定了应该调用的是的而不是真正传入的对象解决方法就是迟绑定迟捆绑动态绑定运行时绑定意味着绑定要根据对象的实际类型发生在运行语言要实现这种动态绑定必须有某种机制来确定运行时对象的类型并调用合适的成员函数对于一种编译语言编译器并不知道实际的对象类型编译器并不知道类型的指针或引用指向的实际的对象类型动态多态性是通过虚函数来实现的虚函数允许子类派生类重新定义父类基类成员函数而子类派生类重新定义父类基类虚函数的做法称为覆盖或者称为重写对于特定的函数进行动态绑定要求在基类中声明这个函数的时候使用关键字动态绑定也就对函数起作用为创建一个需要动态绑定的虚成员函数可以简单在这个函数声明前面加上关键字定义时候不需要如果一个函数在基类中被声明为那么在所有派生类中它都是的在派生类中函数的重定义称为重写关键字只能修饰成员函数构造函数不能为虚函数将需要动态绑定的函数定义为虚函数在子类中重写虚函数将对象转成父类的对象这里是向上转型向上转型后的对象调用父类中的函数多态案例未使用多态实现快递为你快速发送包裹快递为您发送包裹哪里都能送到快递为您发送包裹最快当日可达这里违背了程序设计原则中的开闭原则开闭原则对拓展开放对修改关闭意义是当有新的功能增加对时候直接拓展模块而不是修改现有的实现部分使用多态实现快递公司类快递公司发送包裹快递为你快速发送包裹快递为您发送包裹哪里都能送到快递为您发送包裹最快当日可达纯虚函数与抽象类在设计程序时常常希望基类仅仅作为其派生类的一个接口这就是说仅想对基类进行向上类型转换使用它的接口而不希望用户实际的创建一个基类的对象同时创建一个纯虚函数允许接口中放置成员原函数而不一定要提供一段可能对这个函数毫无意义的代码例如我们可以设计一个交通工具类提供最基础的运输的功能我们在使用到交通工具的时候往往并不是寻求交通工具的对象而是寻求的交通工具子类的对象例如公交车例如地铁例如共享单车等而我们需要的其实是在这些子类中的运输功能实现因此父类交通工具类中的运输功能怎么去实现没有意义纯虚函数使用来修饰一个函数并且实现部分直接设置为如果一个类中包含了纯虚函数那么这个类也自动的编程了抽象类了抽象类无法实例化对象并且子类必须重写实现父类中的纯虚函数否则子类也是抽象类定义纯虚函数此时的类是抽象类公交车运输乘客地铁运输乘客抽象类无法实例化对象纯虚函数与多继承多继承带来了一些争议但是接口继承可以说一种毫无争议的运用了绝大数面向对象语言都不支持多继承但是绝大数面向对象对象语言都支持接口的概念中没有接口的概念但是可以通过纯虚函数实现接口接口类中只有函数原型定义没有任何数据定义多重继承接口不会带来二义性和复杂性问题接口类只是一个功能声明并不是功能实现子类需要根据功能说明定义功能实现注意除了析构函数外其他声明都是纯虚函数定义一个功能集合厨师类定义一个功能集合保姆类使得人类同时具备这两种功能对继承到的纯虚函数进行实现买菜做饭吃饭扫地洗衣服虚析构函数析构函数是对象生命周期的终点在对象被销毁之前调用在析构函数中我们一般会进行资源的释放空间的销毁的操作例如在一个类中有指向堆空间内存的指针我们需要通过这样的指针来销毁对应的堆空间但是在多态中父类的引用可以指向子类的对象那么我们在使用父类的引用来销毁空间的话就有可能会出现子类中引用的堆空间无法销毁的情况造成内存泄漏而解决方案就是为父类添加虚析构函数父类的析构函数执行了子类的析构函数执行了如果没有虚析构函数的话这里通过来销毁空间的确可以把开辟的堆空间给销毁掉但是由于只会触发父类中的析构函数因此无法将属性开辟的堆空间给销毁掉造成内存泄漏解决方案将父类的析构函数作为虚析构函数完成动态绑定虚析构函数也可以做成纯虚析构函数如果一个类中包含了纯虚析构函数那么这个类依然是一个抽象类无法实例化对象总结如果一个类的目的不是为了实现多态仅仅是作为一个基类来使用那么无需将析构函数设置为虚析构函数如果一个类的目的就是为了实现多态的那么这个类的析构函数就有必要设置为虚析构函数结构体结构体的定义与使用在中还有一种用户自定义的数据类型结构体结构体的定义与使用基本与类相同定义结构体结构体中定义的属性结构体中的构造函数结构体中的函数正在努力学习结构体中的析构函数结构体析构函数创建结构体对象创建结构体对象时候的关键字可以省略不写访问成员通过有参构造创建结构体对象在堆上创建结构体对象结构体与类的区别对结构体进行了很多的拓展是的对结构体用于与类几乎相同的功能可以设计属性函数可以设计构造析构甚至可以有继承可以有多态现在看来的结构体与类的区别主要是一点默认的访问权限不同类成员默认的访问权限是结构体成员默认的访问权限是模板模板的介绍提供了函数模板所谓函数模板实际上是建立一个通用函数其函数类型和形参类型不具体制定用一个虚拟的类型来代表这个通用函数就称为函数模板凡是函数体相同的函数都可以用这个模板代替不必定义多个函数只需在模板中定义一次即可在调用函数时系统会根据实参的类型来取代模板中的虚拟类型从而实现不同函数的功能提供两种模板机制函数模板和类模板总结模板把函数或类要处理的数据类型参数化表现为参数的多态性成为类属模板用于表达逻辑结构相同但具体数据元素类型不同的数据对象的通用行为函数模板函数模板的定义需求我想要设计一个函数实现两个变量的值的交换需求我想要设计一个函数实现两个变量的值的交换那么我需要再对两个类型的变量进行交换是不是还需要再写一个函数呢需要交换的变量的类型越多我就越需要写更多的重复的函数而且一旦需求变更了交换的逻辑需要做一些小小的改变那么每一个函数我都得修改一下非常的复杂我如果能够设计一个通用的函数能够把类型当作参数传递到这个函数中就可以简化很多很多的工作了这就是函数模板定义函数模板模板关键字定义虚拟类型关键字也可以使用定义的一个虚拟的类型在这里暂不确定是什么类型等到调用这个函数的时候就可以确定了函数模板的使用显式指定类型可以自动根据实参的类型进行推导这里调用的中类型被推导为类型这里调用的中类型被推导为类型注意事项类型推导的时候需要保证一致性不满足一致性无法推导例如第一个实参是类型推导的类型为第二个实参是类型推导的类型为不一致函数模板案例需求定义一个模板函数实现对一个数组中对元素进行升序排序需求定义一个模板函数实现将一个数组中对元素拼接成为字符串返回定义一个定义一个定义一个函数模板与普通函数函数模板和普通函数在调用的时候需要注意普通函数调用是可以发生自动的类型转换的函数模板调用是不可以发生自动的类型转换的如果调用函数的时候实参既可以匹配普通函数又可以匹配函数模板则优先匹配普通函数定义一个函数模板调用普通函数类型可以自动转换这里进行了类型的自动转换是类型被转型成了类型调用函数模板类型不可以自动转换这里直接错误因为这里不允许类型的转换如果实参既可以匹配普通函数又可以匹配函数参数则优先普通函数调用函数模板的局限性函数模板虽然很通用但是并不是万能的有时候也会有不适配的情况出现对于上述的函数模板来说如果是比较整型浮点型甚至字符类型的数据都是没有问题的可是如果我设置为类型呢两个对象无法使用进行比较这里自然也就出问题了那么如何解决这样的问题呢重载运算符重载运算符通过函数模板的重载来解决函数模板的重载就是为了解决特定类型的对象的问题通过函数模板的重载可以为这些特定的数据类型提供具像化的模板类模板类模板的定义类模板和函数模板的定义和使用基本是一样的如何定义函数模板就如何定义类模板但是类模板与函数模板还是有点区别的类模板不能自动类型推导创建对象不能类型推导只能自己指定类型创建对象类模板做函数参数参数中明确模板类参数中使用模板参数明确模板类调用参数模板类模板继承定义模板类普通类继承模板类的时候必须明确指定类型这里继承到的的数据类型是这里继承到的的数据类型是类模板中的成员函数创建时机类模板中的成员函数在编译的时候是不会创建的是在调用这个函数的时候创建汪汪呼呼在类设计完成后直接编译程序发现是没有问题的调用函数的时候也是没有问题的可以正常调用调用函数的时候就出问题了不能调用了原因类模板中的成员函数是在调用的时候才会创建的因为在编译的时候只是知道有一个对象是但是具体是什么类型不知道在调用的时候创建了这个函数而我们设置的类型是类型没有问题可以正常执行在调用的时候创建了这个函数判断的类型是类型而在类中不存在函数因此就报错了类模板类外实现构造函数类外实现普通函数类外实现类模板头文件和原文件分离问题我们在写程序的时候很多时候都是需要将类的声明和实现分开来写将类的声明部分写到文件中将类的实现部分写在文件中在使用到这个类的时候直接包含文件即可但是如果是一个模板类这样做是有问题的构造函数类外实现普通函数类外实现通过无参构造创建对象没有问题通过有参构造创建对象出问题了问题出现原因我们虽然引入了文件但是模板类中的函数是在调用的时候才会创建的因此在编译阶段也不会管对应的文件中的实现部分而到了使用到这个函数的时候发现这个函数已经创建了但是没有实现因此就报错了相当于我们只是在中声明了函数但是并没有实现如何解决问题使用引入文件将类的声明和实现放到一个文件中这个文件我们习惯上会定义为文件但是并不是绝对的只是一个习惯和约定的问题类模板遇到友元全局友元函数类外实现定义类全局友元函数类外实现在类之前定义全局友元函数类内实现无需进行什么处理直接在这里写实现即可全局友元函数类外实现在函数的后面添加一对尖括号表示一个模板函数标准模板库概述长久以来软件界一直希望建立一种可重复利用的东西以及一种得以制造出可重复运用的东西的方法让程序员的心血不止于随时间的迁移人事异动而烟消云散从函数类别函数库类别库各种组件从模块化设计到面向对象为的就是复用性的提升复用性必须建立在某种标准之上但是在许多环境下就连软件开发最基本的数据结构和算法都未能有一套标准大量程序员被迫从事大量重复的工作竟然是为了完成前人已经完成而自己手上并未拥有的程序代码这不仅是人力资源的浪费也是挫折与痛苦的来源为了建立数据结构和算法的一套标准并且降低他们之间的耦合关系以提升各自的独立性弹性交互操作性相互合作性诞生了基本概念标准模板库是惠普实验室开发的一系列软件的统称现在主要出现在中但是在引入之前该技术已经存在很长时间了从广义上分为容器算法迭代器容器和算法之间通过迭代器进行无缝连接几乎所有的代码都采用了模板类或者模板函数这相比传统的由函数和类组成的库来说提供了更好的代码重用机会标准模板库在我们标准程序库中隶属于的占到了以上六大组件简介提供了六大组件彼此之间可以组合套用这六大组件分别是容器算法迭代器仿函数适配器配接器空间配置器容器各种数据结构如等用来存放数据从实现角度来看容器是一种算法各种常用的算法如从实现的角度来看算法是一种迭代器扮演了容器与算法之间的胶合剂共有五种类型从实现角度来看迭代器是一种将等指针相关操作予以重载的所有容器都附带有自己专属的迭代器只有容器的设计者才知道如何遍历自己的元素原生指针也是一种迭代器仿函数行为类似函数可作为算法的某种策略从实现角度来看仿函数是一种重载了的或者适配器一种用来修饰容器或者仿函数或迭代器接口的东西空间配置器负责空间的配置与管理从实现角度看配置器是一个实现了动态空间配置空间管理空间释放的六大组件的交互关系容器通过空间配置器取得数据存储空间算法通过迭代器存储容器中的内容仿函数可以协助算法完成不同的策略的变化适配器可以修饰仿函数优点是的一部分因此不用额外安装什么它被内建在你的编译器之内的一个重要特性是将数据和操作分离数据由容器类别加以管理操作则由可定制的算法定义迭代器在两者之间充当粘合剂以使算法可以和容器交互运作程序员可以不用思考具体的实现过程只要能够熟练使用就了这样他们就可以把精力放在程序开发的别的方面具有高可重用性高性能高移植性跨平台的优点高可重用性中几乎所有的代码都采用了模板类和模版函数的方式实现这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会关于模板的知识已经给大家介绍了高性能如可以高效地从十万条记录里面查找出指定的记录因为是采用红黑树的变体实现的高移植性如在项目上用编写的模块可以直接移植到项目上三大组件容器容器置物之所也研究数据的特定排列方式以利于搜索或排序或其他特殊目的这一门学科我们称为数据结构大学信息类相关专业里面与编程最有直接关系的学科首推数据结构与算法几乎可以说任何特定的数据结构都是为了实现某种特定的算法容器就是将运用最广泛的一些数据结构实现出来常用的数据结构数组链表树栈队列集合映射表根据数据在容器中的排列特性这些数据分为序列式容器和关联式容器两种序列式容器强调值的排序序列式容器中的每个元素均有固定的位置除非用删除或插入的操作改变这个位置容器容器容器等关联式容器是非线性的树结构更准确的说是二叉树结构各元素之间没有严格的物理上的顺序关系也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序关联式容器另一个显著特点是在值中选择一个值作为关键字这个关键字对值起到索引的作用方便查找容器容器容器可以嵌套容器算法算法问题之解法也以有限的步骤解决逻辑或数学上的问题这一门学科我们叫做算法广义而言我们所编写的每个程序都是一个算法其中的每个函数也都是一个算法毕竟它们都是用来解决或大或小的逻辑问题或数学问题收录的算法经过了数学上的效能分析与证明是极具复用价值的包括常用的排序查找等等特定的算法往往搭配特定的数据结构算法与数据结构相辅相成算法分为质变算法和非质变算法质变算法是指运算过程中会更改区间内的元素的内容例如拷贝替换删除等等非质变算法是指运算过程中不会更改区间内的元素内容例如查找计数遍历寻找极值等等迭代器迭代器是一种抽象的设计概念现实程序语言中并没有直接对应于这个概念的实物定义如下提供一种方法使之能够依序寻访某个容器所含的各个元素而又无需暴露该容器的内部表示方式迭代器的设计思维的关键所在的中心思想在于将容器和算法分开彼此独立设计最后再一贴胶着剂将他们撮合在一起从技术角度来看容器和算法的泛型化并不困难的和可分别达到目标如何设计出两这个之间的良好的胶着剂才是大难题迭代器的种类输入迭代器提供对数据的只读访问只读支持输出迭代器提供对数据的只写访问只写支持前向迭代器提供读写操作并能向前推进迭代器读写支持双向迭代器提供读写操作并能向前和向后操作读写支持随机访问迭代器提供读写操作并能以跳跃的方式访问容器的任意数据是功能最强的迭代器读写支持常用容器容器容器基本概念风格字符串以空字符结尾的字符数组太过复杂难于掌握不适合大程序的开发所以标准库定义了一种类的字符串与语言的字符串比较语言是一个指针是一个类内部封装了用来管理这个容器类中封装了很多的功能函数非常实用例如等不用考虑内存释放和越界的问题管理所分配的内存每一次的复制取值都由类负责维护不用担心复制越界和取值越界等容器常用操作构造函数创建一个空的字符串例如使用一个对象初始化另一个对象使用字符串初始化使用个字符初始化基本赋值操作类型字符串赋值给当前的字符串把字符串赋给当前的字符串字符赋值给当前的字符串把字符串赋给当前的字符串把字符串的前个字符赋给当前的字符串把字符串赋给当前字符串用个字符赋给当前字符串将从开始个字符赋值给字符串存取字符操作通过方式取字符通过方法获取字符拼接操作重载操作符重载操作符重载操作符把字符串连接到当前字符串结尾把字符串的前个字符连接到当前字符串结尾同把字符串中从开始的个字符连接到当前字符串结尾在当前字符串结尾添加个字符查找和替换查找第一次出现位置从开始查找查找第一次出现位置从开始查找从位置查找的前个字符第一次位置查找字符第一次出现位置查找最后一次位置从开始查找查找最后一次出现位置从开始查找从查找的前个字符最后一次位置查找字符最后一次出现位置替换从开始个字符为字符串替换从开始的个字符为字符串比较操作函数在时返回时返回时返回比较区分大小写比较时参考字典顺序排越前面的越小大写的比小写的小与字符串比较与字符串比较子串返回由开始的个字符组成的字符串插入和删除操作插入字符串插入字符串在指定位置插入个字符删除从开始的个字符和语言风格字符串转换转转在中存在一个从到的隐式类型转换却不存在从一个对象到的自动类型转换对于类型的字符串可以通过函数返回对象对应的通常程序员在整个程序中应坚持使用类对象直到必须将内容转化为时才将其转换为提示为了修改字符串的内容下标操作符和都会返回字符的引用但当字符串的内存被重新分配之后可能发生错误容器容器基本概念的数据安排以及操作方式与非常相似两者的唯一差别在于空间的运用的灵活性是静态空间一旦配置了就不能改变要换大一点或者小一点的空间可以一切琐碎得由自己来首先配置一块新的空间然后将旧空间的数据搬往新空间再释放原来的空间是动态空间随着元素的加入它的内部机制会自动扩充空间以容纳新元素因此的运用对于内存的合理利用与运用的灵活性有很大的帮助我们再也不必害怕空间不足而一开始就要求一个大块头的了容器常用操作的构造函数采用模板实现类实现默认构造函数将区间中的元素拷贝给本身构造函数将个拷贝给本身拷贝构造函数例子使用第二个构造函数我们可以的常用赋值函数将区间中的数据拷贝赋值给本身将个拷贝赋值给本身重载等号操作符将与本身的元素互换的大小操作返回容器中元素的个数判断容器是否为空重新指定容器的长度为若容器变长则以默认值填充新位置如果容器变短则末尾超出容器长度的元素被删除重新指定容器的长度为若容器变长则以值填充新位置如果容器变短则末尾超出容器长度的元素被删除容器的容量容器预留个元素长度预留位置不初始化元素不可访问的数据存取操作返回索引所指的数据如果越界抛出异常返回索引所指的数据越界时运行直接报错返回容器中第一个数据元素返回容器中最后一个数据元素插入和删除操作迭代器指向位置插入个元素尾部插入元素删除最后一个元素删除迭代器从到之间的元素删除迭代器指向的元素删除容器中所有元素迭代器维护一个线性空间所以不论元素的型别如何普通指针都可以作为的迭代器因为迭代器所需要的操作行为如普通指针天生具备支持随机存取而普通指针正有着这样的能力所以提供的是随机访问迭代器提供了函数用来返回指向首元素的指针提供了函数用来返回指向最后一位元素的下一位的指针创建容器向容器中添加元素使用迭代器遍历容器使用迭代器倒序遍历容器迭代器遍历容器可以缩写为循环的写法在使用迭代器遍历容器的过程中可以通过指针或者是引用来修改到容器中的值小案例巧用收缩内存空间此时通过改变容器大小容量没有改变预留空间预先开辟空间容器容器基本概念容器是单向开口的连续内存空间则是一种双向开口的连续线性空间所谓的双向开口意思是可以在头尾两端分别做元素的插入和删除操作当然容器也可以在头尾两端插入元素但是在其头部操作效率奇差无法被接受容器和容器最大的差异一在于允许对头端进行元素的插入和删除操作二在于没有容量的概念因为它是动态的以分段连续空间组合而成随时可以增加一段新的空间并链接起来换句话说像那样旧空间不足而重新配置一块更大空间然后复制元素再释放旧空间这样的事情在身上是不会发生的也因此没有必须要提供所谓的空间保留功能虽然容器也提供了但是它的迭代器并不是普通的指针其复杂度和不是一个量级这当然影响各个运算的层面因此除非有必要我们应该尽可能的使用而不是对进行的排序操作为了最高效率可将先完整的复制到一个中对容器进行排序再复制回容器常用操作构造函数默认构造形式构造函数将区间中的元素拷贝给本身构造函数将个拷贝给本身拷贝构造函数赋值操作将区间中的数据拷贝赋值给本身将个拷贝赋值给本身重载等号操作符将与本身的元素互换大小操作返回容器中元素的个数判断容器是否为空重新指定容器的长度为若容器变长则以默认值填充新位置如果容器变短则末尾超出容器长度的元素被删除重新指定容器的长度为若容器变长则以值填充新位置如果容器变短则末尾超出容器长度的元素被删除双端操作和删除在容器尾部添加一个数据在容器头部插入一个数据删除容器最后一个数据删除容器第一个数据数据存取返回索引所指的数据如果越界抛出返回索引所指的数据如果越界不抛出异常直接出错返回第一个数据返回最后一个数据插入操作在位置插入一个元素的拷贝返回新数据的位置在位置插入个数据无返回值在位置插入区间的数据无返回值删除操作移除容器的所有数据删除区间的数据返回下一个数据的位置删除位置的数据返回下一个数据的位置小案例有名选手选手个评委分别对每一名选手打分去除最高分去除评委中最低分取平均分创建五名选手放到中遍历容器取出来每一个选手执行循环可以把个评分打分存到容器中算法对容器中分数排序去除最高和最低分容器遍历一遍累加分数累加分数平均分容器容器基本概念是一种先进后出的数据结构它只有一个出口形式如图所示容器允许新增元素移除元素取得栈顶元素但是除了最顶端外没有任何其他方法可以存取的其他元素换言之不允许有遍历行为有元素推入栈的操作称为将元素推出的操作称为是没有迭代器的所有元素的进出都必须符合先进后出的条件只有顶端的元素才有机会被外界取用不提供遍历功能也不提供迭代器容器常用操作构造函数采用模板类实现对象的默认构造形式拷贝构造函数赋值操作重载等号操作符数据存取操作向栈顶添加元素从栈顶移除第一个元素返回栈顶元素大小操作判断堆栈是否为空返回堆栈的大小容器容器基本概念是一种先进先出的数据结构它有两个出口容器允许从一端新增元素从另一端移除元素容器没有迭代器所有元素的进出都必须符合先进先出的条件只有的顶端元素才有机会被外界取用不提供遍历功能也不提供迭代器容器常用操作构造函数采用模板类实现对象的默认构造形式拷贝构造函数存取插入删除操作往队尾添加元素从队头移除第一个元素返回最后一个元素返回第一个元素赋值操作重载等号操作符大小操作判断队列是否为空返回队列的大小容器容器基本概念链表是一种物理存储单元上非连续非顺序的存储结构数据元素的逻辑顺序是通过链表中的指针链接次序实现的链表由一系列结点链表中每一个元素称为结点组成结点可以在运行时动态生成每个结点包括两个部分一个是存储数据元素的数据域另一个是存储下一个结点地址的指针域相较于的连续线性空间就显得复杂许多它的好处是每次插入或者删除一个元素就是配置或者释放一个元素的空间因此对于空间的运用有绝对的精准一点也不浪费而且对于任何位置的元素插入或元素的移除永远是常数时间和是两个最常被使用的容器容器是一个双向链表采用动态存储分配不会造成内存浪费和溢出链表执行插入和删除操作十分方便修改指针即可不需要移动大量元素链表灵活但是空间和时间额外耗费较大的迭代器容器不能像一样以普通指针作为迭代器因为其节点不能保证在同一块连续的内存空间上迭代器必须有能力指向的节点并有能力进行正确的递增递减取值成员存取操作所谓正确的递增递减取值成员取用是指递增时指向下一个节点递减时指向上一个节点取值时取的是节点的数据值成员取用时取的是节点的成员由于是一个双向链表迭代器必须能够具备前移后移的能力所以容器提供的是有一个重要的性质插入操作和删除操作都不会造成原有迭代器的失效这在是不成立的因为的插入操作可能造成记忆体重新配置导致原有的迭代器全部失效甚至元素的删除也只有被删除的那个元素的迭代器失效其他迭代器不受任何影响容器常用操作构造函数采用采用模板类实现对象的默认构造形式构造函数将区间中的元素拷贝给本身构造函数将个拷贝给本身拷贝构造函数元素插入和删除操作在容器尾部加入一个元素删除容器中最后一个元素在容器开头插入一个元素从容器开头移除第一个元素在位置插元素的拷贝返回新数据的位置在位置插入个数据无返回值在位置插入区间的数据无返回值移除容器的所有数据删除区间的数据返回下一个数据的位置删除位置的数据返回下一个数据的位置删除容器中所有与值匹配的元素大小操作返回容器中元素的个数判断容器是否为空重新指定容器的长度为若容器变长则以默认值填充新位置如果容器变短则末尾超出容器长度的元素被删除重新指定容器的长度为若容器变长则以值填充新位置如果容器变短则末尾超出容器长度的元素被删除赋值操作将区间中的数据拷贝赋值给本身将个拷贝赋值给本身重载等号操作符将与本身的元素互换数据存取操作返回第一个元素返回最后一个元素反转排序反转链表比如包含元素运行此方法后就包含元素排序容器容器基本概念的特性是所有元素都会根据元素的值自动被排序不允许两个元素有相同的值我们可以通过的迭代器改变元素的值吗不行因为元素值就是其值关系到元素的排序规则如果任意改变元素值会严重破坏组织换句话说的是一种拥有和某些相同的性质当对容器中的元素进行插入操作或者删除操作的时候操作之前所有的迭代器在操作完成之后依然有效被删除的那个元素的迭代器必然是一个例外特性及用法和完全相同唯一的差别在于它允许值重复和的底层实现是红黑树红黑树为平衡二叉树的一种树的简单知识二叉树就是任何节点最多只允许有两个字节点分别是左子结点和右子节点二叉树示意图二叉搜索树是指二叉树中的节点按照一定的规则进行排序使得对二叉树中元素访问更加高效二叉搜索树的放置规则是任何节点的元素值一定大于其左子树中的每一个节点的元素值并且小于其右子树的值因此从根节点一直向左走一直到无路可走即得到最小值一直向右走直至无路可走可得到最大值那么在二叉搜索树中找到最大元素和最小元素是非常简单的事情下图为二叉搜索树上面我们介绍了二叉搜索树那么当一个二叉搜索树的左子树和右子树不平衡的时候那么搜索依据上图表示搜索所花费的时间要比搜索所花费的时间要多由于我们的输入或者经过我们插入或者删除操作二叉树失去平衡造成搜索效率降低所以我们有了一个平衡二叉树的概念所谓的平衡不是指的完全平衡容器常用操作构造函数默认构造函数默认构造函数拷贝构造函数赋值重载等号操作符交换两个集合容器大小操作返回容器中元素的数目判断容器是否为空插入和删除操作在容器中插入元素清除所有元素删除迭代器所指的元素返回下一个元素的迭代器删除区间的所有元素返回下一个元素的迭代器删除容器中值为的元素查找操作查找键是否存在若存在返回该键的元素的迭代器若不存在返回查找键的元素个数返回第一个元素的迭代器返回第一个元素的迭代器返回容器中与相等的上下限的两个迭代器对组对组将一对值组合成一个值这一对值可以具有不同的数据类型两个值可以分别用的两个公有属性和访问类模板如何创建对组第一种方法创建一个对组访问第一个值访问第二个值第二种赋值容器基本概念的特性是所有元素都会根据元素的键值自动排序所有的元素都是同时拥有实值和键值的第一元素被视为键值第二元素被视为实值不允许两个元素有相同的键值我们可以通过的迭代器改变的键值吗答案是不行因为的键值关系到元素的排列规则任意改变键值将会严重破坏组织如果想要修改元素的实值那么是可以的和拥有相同的某些性质当对它的容器元素进行新增操作或者删除操作时操作之前的所有迭代器在操作完成之后依然有效当然被删除的那个元素的迭代器必然是个例外和的操作类似唯一区别键值可重复和都是以红黑树为底层实现机制常用操作构造函数默认构造函数拷贝构造函数赋值操作重载等号操作符交换两个集合容器大小操作返回容器中元素的数目判断容器是否为空插入操作往容器插入元素返回第一种通过的方式插入对象小张第二种通过的方式插入对象校长第三种通过的方式插入对象小李第四种通过数组的方式插入值小刘小王删除元素删除所有元素删除迭代器所指的元素返回下一个元素的迭代器删除区间的所有元素返回下一个元素的迭代器删除容器中为的对组查找操作查找键是否存在若存在返回该键的元素的迭代器若不存在返回返回容器中为的对组个数对来说要么是要么是对来说值可能大于返回第一个元素的迭代器返回第一个元素的迭代器返回容器中与相等的上下限的两个迭代器案例公司今天招聘了个员工名员工进入公司之后需要指派员工在那个部门工作人员信息有姓名年龄电话工资等组成通过进行信息的插入保存显示分部门显示员工信息显示全部员工信息案例公司今天招聘了个员工名员工进入公司之后需要指派员工在那个部门工作人员信息有姓名年龄电话工资等组成通过进行信息的插入保存显示分部门显示员工信息显示全部员工信息销售部门研发部门财务部门所有部门员工类员工姓名员工年龄员工工资员工电话创建个员工员工名员工分配到不同的部门用户的操作当前员工信息姓名年龄工资电话请对该员工进行部门分配销售部门研发部门财务部门将该员工加入到销售部门您的输入有误请重新输入销售部门研发部门财务部门员工部门分配完毕打印员工信息姓名年龄工资电话姓名年龄工资电话根据用户操作显示不同部门的人员列表用户操作菜单请输入您的操作销售部门研发部门财务部门所有部门退出您的输入有误请重新输入创建的个员工未分组保存分组后员工信息创建个员工名员工分配到不同的部门根据用户输入显示不同部门员工信息列表或者显示全部员工的信息列表算法函数对象重载函数调用操作符的类其对象常称为函数对象即它们是行为类似函数的对象也叫仿函数其实就是重载操作符使得类对象可以像函数那样调用注意函数对象仿函数是一个类不是一个函数函数对象仿函数重载了操作符使得它可以像函数一样调用分类假定某个类有一个重载的而且重载的要求获取一个参数我们就将这个类称为一元仿函数相反如果重载的要求获取两个参数就将这个类称为二元仿函数函数对象的作用主要是什么提供的算法往往都有两个版本其中一个版本表现出最常用的某种运算另一版本则允许用户通过参数的形式来指定所要采取的策略函数对象是重载了函数调用符号的类函数对象重载了操作符的类实例化的对象可以像普通函数那样调用可以有参数可以有返回值函数对象超出了普通函数的概念可以保存函数的调用状态函数对象作为参数参数匿名函数对象谓语谓词是指普通函数或重载的返回值是类型的函数对象仿函数如果接受一个参数那么叫做一元谓词如果接受两个参数那么叫做二元谓词谓词可作为一个判断式一元谓词没有找到找到了二元谓词默认从小到大使用函数对象改变算法策略排序从大到小内建函数对象内建了一些函数对象分为算数类函数对象关系运算类函数对象逻辑运算类仿函数这些仿函数所产生的对象用法和一般函数完全相同当然我们还可以产生无名的临时对象来履行函数功能使用内建函数对象需要引入头文件个算数类函数对象除了是一元运算其他都是二元运算加法仿函数减法仿函数乘法仿函数除法仿函数取模仿函数取反仿函数个关系运算类函数对象每一种都是二元运算等于不等于大于大于等于小于小于等于逻辑运算类运算函数为一元运算其余为二元运算逻辑与逻辑或逻辑非内建函数对象举例取反仿函数加法仿函数大于仿函数函数对象适配器函数适配器现在我有这个需求在遍历容器的时候我希望将容器中的值全部加上之后显示出来怎么做我们直接给函数对象绑定参数编译阶段就会报错如果我们想使用绑定适配器需要我们自己的函数对象继承或者根据我们函数对象是一元函数对象还是二元函数对象函数适配器请输入起始值总结和区别将参数绑定为函数对象的第一个参数将参数绑定为函数对象的第二个参数将二元函数对象转为一元函数对象取反适配器返回第一个大于的迭代器返回第一个小于迭代器自定义输入没找到找到排序二元函数对象对一元函数对象取反对二元函数对象取反函数指针适配器把一个普通的函数指针适配成函数对象成员函数适配器打印函数成员函数姓名年龄利用将内部成员函数适配创建数据如果容器存放的是对象指针那么用如果容器中存放的是对象实体那么用算法概述算法主要是由头文件组成是所有头文件中最大的一个其中常用的功能涉及到比较交换查找遍历复制修改反转排序合并等体积很小只包括在几个序列容器上进行的简单运算的模板函数定义了一些模板类用以声明函数对象常用遍历算法遍历算法遍历算法遍历容器元素开始迭代器结束迭代器函数回调或者函数对象函数对象普通函数函数对象算法基本用法遍历算法返回值绑定参数输出算法算法将指定容器区间元素搬运到另一容器中注意不会给目标容器分配内存所以需要我们提前分配好内存源容器开始迭代器源容器结束迭代器目标容器开始迭代器回调函数或者函数对象返回目标容器迭代器将一个容器中的值搬运到另一个容器中目标容器给开辟空间将中的元素搬运到打印将容器和容器中的元素相加放入到第三个容器中目标容器给开辟空间打印常用查找算法算法查找元素容器开始迭代器容器结束迭代器查找的元素返回查找元素的位置算法条件查找容器开始迭代器容器结束迭代器回调函数或者谓词返回类型的函数对象查找返回否则算法查找相邻重复元素容器开始迭代器容器结束迭代器回调函数或者谓词返回类型的函数对象返回相邻元素的第一个位置的迭代器算法二分查找法注意在无序序列中不可用容器开始迭代器容器结束迭代器查找的元素查找返回否则算法统计元素出现次数容器开始迭代器容器结束迭代器回调函数或者谓词返回类型的函数对象返回元素个数算法统计元素出现次数容器开始迭代器容器结束迭代器回调函数或者谓词返回类型的函数对象返回元素个数常用排序算法算法容器元素合并并存储到另一容器中注意两个容器必须是有序的容器开始迭代器容器结束迭代器容器开始迭代器容器结束迭代器目标容器开始迭代器算法容器元素排序容器开始迭代器容器结束迭代器回调函数或者谓词返回类型的函数对象算法对指定范围内的元素随机调整次序容器开始迭代器容器结束迭代器算法反转指定范围的元素容器开始迭代器容器结束迭代器常用拷贝和替换算法算法将容器内指定范围的元素拷贝到另一容器中容器开始迭代器容器结束迭代器目标起始迭代器算法将容器内指定范围的旧元素修改为新元素容器开始迭代器容器结束迭代器旧元素新元素算法将容器内指定范围满足条件的元素替换为新元素容器开始迭代器容器结束迭代器函数回调或者谓词返回类型的函数对象新元素算法互换两个容器的元素容器容器常用算数生成算法算法计算容器元素累计总和容器开始迭代器容器结束迭代器累加值算法向容器中添加元素容器开始迭代器容器结束迭代器填充元素常用集合算法算法求两个集合的交集注意两个集合必须是有序序列容器开始迭代器容器结束迭代器容器开始迭代器容器结束迭代器目标容器开始迭代器目标容器的最后一个元素的迭代器地址算法求两个集合的并集注意两个集合必须是有序序列容器开始迭代器容器结束迭代器容器开始迭代器容器结束迭代器目标容器开始迭代器目标容器的最后一个元素的迭代器地址算法求两个集合的差集注意两个集合必须是有序序列容器开始迭代器容器结束迭代器容器开始迭代器容器结束迭代器目标容器开始迭代器目标容器的最后一个元素的迭代器地址',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-20 19:57:03',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="./src/css/theme.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/src/images/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.zianyoyo.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.xtone.club/" title="归一"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="归一"/><span class="back-menu-item-text">归一</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/favicon.ico" title="安知鱼主题官方文档"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼主题官方文档"/><span class="back-menu-item-text">安知鱼主题官方文档</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Zian</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-C/" style="font-size: 1.05rem;">C/C++<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/JS/" style="font-size: 1.05rem;">JS<sup>1</sup></a><a href="/tags/Tag-Plugins/" style="font-size: 1.05rem;">Tag Plugins<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/11/"><span class="card-archive-list-date">十一月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80/" itemprop="url">C语言</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C-C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C/C++</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C/C++程序设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-10-04T15:46:02.000Z" title="发表于 2024-10-04 23:46:02">2024-10-04</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-20T11:57:03.641Z" title="更新于 2024-10-20 19:57:03">2024-10-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">44.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>172分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C/C++程序设计"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为山东"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>山东</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/src/images/pageCover/c++.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/10/04/c++/"><header><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80/" itemprop="url">C语言</a><a href="/tags/C-C/" tabindex="-1" itemprop="url">C/C++</a><h1 id="CrawlerTitle" itemprop="name headline">C/C++程序设计</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Zian</span><time itemprop="dateCreated datePublished" datetime="2024-10-04T15:46:02.000Z" title="发表于 2024-10-04 23:46:02">2024-10-04</time><time itemprop="dateCreated datePublished" datetime="2024-10-20T11:57:03.641Z" title="更新于 2024-10-20 19:57:03">2024-10-20</time></header><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><blockquote>
<p>第一个程序：打印输出HelloWorld</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>#include</code>：引用头文件</li>
<li><code>main</code>：程序的入口（主函数），一个项目只能有一个主函数</li>
<li><code>std</code>：已经定义的命名空间，可释放注释,省略std<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!!&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><code>cout</code>：C++中的输出类</li>
<li><code>endl</code>：换行函数，可以释放缓存区</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><ul>
<li>以两个斜线<code>//</code>开始，斜线之后的内容都是注释的内容，不会被编译<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Hello World!!&quot; &lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><ul>
<li>以<code>/*</code>开始，以<code>*/</code>结束，中间的所有内容都是注释的内容，可以换行，内容不会被编译<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* std::cout &lt;&lt; &quot;Hello World!!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;Hello World!!&quot; &lt;&lt; std::endl; */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><blockquote>
<p>标识符：是由字母,数字,下划线,组成的一个字符序列，用来表示程序中的数据</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span> <span class="comment">// x代表10</span></span><br><span class="line">y = <span class="number">20</span> <span class="comment">// y代表20</span></span><br><span class="line">x + y = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>标识符的命名规范</p>
</blockquote>
<ul>
<li>由字母,数字,下划线组成，不能有其他的组成部分</li>
<li>不能以数字开头，需要以字母或者下划线组成</li>
<li>不能与系统关键字重复</li>
<li>区分大小写</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><blockquote>
<p>整型：就是整数的类型，描述的是整数数字</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">空间大小</th>
<th align="center">数据范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">[2^-15,2^15-1]</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">[2^-31,2^31-1]</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">windows：4字节</td>
<td align="center">[2^-31,2^31-1]</td>
</tr>
<tr>
<td align="center">长长整型</td>
<td align="center">long long</td>
<td align="center">8字节</td>
<td align="center">[2^-63,2^63-1]</td>
</tr>
</tbody></table>
<ul>
<li><code>sizeof()</code>：返回一个数据类型或者一个变量的空间占用大小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><blockquote>
<p>浮点型：就是小数的类型，用来描述的是小数数字</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">空间大小</th>
<th align="center">精确范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单精度浮点型</td>
<td align="center">float</td>
<td align="center">4字节</td>
<td align="center">小数点后面7位</td>
</tr>
<tr>
<td align="center">双精度浮点型</td>
<td align="center">double</td>
<td align="center">8字节</td>
<td align="center">小数点后面15位</td>
</tr>
</tbody></table>
<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><blockquote>
<p>用来描述非真即假，非假及真的数据类型</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">空间大小</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">布尔型</td>
<td align="center">bool</td>
<td align="center">1字节</td>
<td align="center">true   |    false</td>
</tr>
</tbody></table>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><blockquote>
<p>用来描述一个文本内容中最小组成单位</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">空间大小</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">1字节</td>
<td align="center">单引号<code>&#39;&#39;</code>引起来的内容</td>
</tr>
</tbody></table>
<h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h2><blockquote>
<p>由若干个字符组成的一个有序的字符序列</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">空间大小</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符串型</td>
<td align="center">std::string</td>
<td align="center"></td>
<td align="center">单引号<code>&quot;&quot;</code>引起来的内容</td>
</tr>
</tbody></table>
<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>变化的量,可以修改值</p>
</blockquote>
<blockquote>
<p>定义变量的语法：</p>
<ol>
<li><code>数据类型</code> <code>标识符(变量名)</code></li>
<li><code>数据类型</code> <code>标识符</code> &#x3D; <code>值</code></li>
<li><code>数据类型</code> <code>标识符1[= 值]</code>，<code>标识符2[= 值]</code>，<code>标识符3[= 值]</code>…</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> c = <span class="number">20</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = <span class="number">30</span>;</span><br><span class="line"><span class="type">float</span> e = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> f = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">bool</span> g = <span class="literal">true</span>;</span><br><span class="line"><span class="type">char</span> h = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">std::string i = <span class="string">&quot;Hello World&quot;</span>; </span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><blockquote>
<p>不变化的量，不可以修改值</p>
</blockquote>
<blockquote>
<p>定义常量的语法：<code>const</code> <code>数据类型</code> <code>标识符(变量名)</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><blockquote>
<p>转义字符<code>\</code></p>
</blockquote>
<ol>
<li>配合某些特殊字符使用，使其变成普通字符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello \&quot; World&quot;</span>; <span class="comment">// 输出：Hello &quot; World </span></span><br></pre></td></tr></table></figure></li>
<li>配合某些特定的普通字符使用，代表某些特殊含义<ul>
<li><code>\t</code>：制表符 tab 四个空格</li>
<li><code>\n</code>：换行符</li>
<li><code>\r</code>：回车符</li>
</ul>
</li>
</ol>
<h1 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h1><blockquote>
<p><code>cin</code>：读取控制台上输入的内容，并且给某一个变量进行赋值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; num; </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1 = <span class="number">0</span>，n2 = <span class="number">0</span>,n3 = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; n1; </span><br><span class="line">std::cin &gt;&gt; n2; </span><br><span class="line">std::cin &gt;&gt; n3;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;n1 = &quot;</span>  &lt;&lt; n1 &lt;&lt; <span class="string">&quot;,n2 = &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot;,n3 = &quot;</span> &lt;&lt; n3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入：123空格456空格789</span></span><br><span class="line"><span class="comment">// 输入：123回车456回车789</span></span><br><span class="line"><span class="comment">// 输出都为：n1 = 123,n2 = 456,n3 = 789</span></span><br><span class="line"><span class="comment">// 输入：3.14 123 -&gt; n1 = 3,n2 = 14,n3 = 123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>缓冲区问题：<br>在控制台输入的内容都被暂存到了一个<code>缓冲区</code>中，<code>cin</code>从<code>缓冲区</code>取数据给变量进行赋值<br>遇到<code>.</code>和<code>空格</code>会被忽略，可使用<code>cin.ignore()</code>来忽略缓冲区的内容</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> num = <span class="number">0</span>,num2 = <span class="number">0</span>,num3 = <span class="number">0</span>;</span><br><span class="line">   cin.<span class="built_in">ignore</span>(); <span class="comment">// 忽略一位`.`和`空格`,参数是忽略个数</span></span><br><span class="line">   cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(),<span class="string">&quot;\n&quot;</span>); <span class="comment">//忽略所有内容</span></span><br><span class="line">   cin &gt;&gt; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以连续输入</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>,num3=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; num2 &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误处理</p>
<ul>
<li>cin内部会维护一个状态，来记录本次的读取操作是否正常</li>
<li>cin.good()；cin读取状态正确 值为1，否则为0</li>
<li>cin.fail()：cin读取状态错误 值为1，否则为0</li>
<li>如果被标记为<code>fail</code>状态，则会影响后续的读取操作</li>
<li><code>cin.clear()</code>：恢复状态，清除错误状态</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个整型的数字：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;good = &quot;</span> &lt;&lt; cin.<span class="built_in">good</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fail = &quot;</span> &lt;&lt; cin.<span class="built_in">fail</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cin.<span class="built_in">clear</span>() <span class="comment">// 若上面的cin输入错误，使用cin.clear()清除的错误状态，后面的输入才可以正常执行</span></span><br><span class="line">    cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(),<span class="string">&quot;\n&quot;</span>); <span class="comment">// 清空缓冲区内容，也可以清除错误状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个整型的数字：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><blockquote>
<p>宏定义：在文件的头部，使用<code>#define</code>来定义一个标识符，用来描述一个字符串，这个字符串就成为宏定义，使用时会自动替换为定义的值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_CODE 1 <span class="comment">// 宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; SUCCESS_CODE;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><blockquote>
<p>为了避免各种类库的命名的标识符冲突，C++引入了关键字<code>namespace</code>(命名空间&#x2F;名字空间&#x2F;名称空间)，可以更好的控制标识符的作用域</p>
</blockquote>
<h2 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h2><blockquote>
<p>定义：<code>namespace</code> <code>命名空间名</code>{ … };<br>使用：<code>命名空间名</code>::<code>成员名</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">   <span class="type">int</span> numA = <span class="number">10</span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 命名空间可以嵌套</span></span><br><span class="line">   <span class="keyword">namespace</span> AA &#123;</span><br><span class="line">      <span class="type">int</span> numAA = <span class="number">20</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">   <span class="type">int</span> numB = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 命名空间的使用</span></span><br><span class="line">   std::cout &lt;&lt; A::numA &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; A::AA::numAA &lt;&lt; std::endl;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命名空间是开放的，可以随时向一个命名空间添加成员</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">   <span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名空间中添加成员</span></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">   <span class="type">int</span> a2 = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; A::a2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h2><blockquote>
<p>直接引用<wavy>指定的命名空间</wavy>或<wavy>指定空间的指定成员</wavy></p>
<ol>
<li>导入命名空间：<code>using</code> <code>namespace</code> <code>命名空间</code></li>
<li>导入命名空间的成员：<code>using</code> <code>命名空间</code>::<code>成员</code></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> A; <span class="comment">// 引用命名空间</span></span><br><span class="line">   <span class="keyword">using</span> A::numA; <span class="comment">// 引用命名空间中的成员</span></span><br><span class="line">   std::cout &lt;&lt; numA &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项：</p>
<ol>
<li>如果引用的命名空间存在和当前的命名空间相同的成员，<wavy>默认使用当前的命名空间中的成员</wavy></li>
<li>如果引用的多个命名空间中存在相同名字的成员，且当前命名空间中没有这个成员，此时出现二义性。<wavy>命名空间不能省略</wavy></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> constant1&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> MAX_SCORE = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> constant2&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> MAX_SCORE = <span class="number">150</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果引用的命名空间存在和当前的命名空间相同的成员，默认使用当前的命名空间中的成员</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> MAX_SCORE = <span class="number">200</span>;</span><br><span class="line">   std::cout &lt;&lt; MAX_SCORE &lt;&lt; std::endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> constant1;</span><br><span class="line">   std::cout &lt;&lt; MAX_SCORE &lt;&lt; std::endl; <span class="comment">// 使用当前命名空间的成员  200</span></span><br><span class="line">   std::cout &lt;&lt; constant1::MAX_SCORE &lt;&lt; std::endl; <span class="comment">// 使用引用的命名空间，则命名空间不能省略 100</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果引用的多个命名空间中存在相同名字的成员，且当前命名空间中没有这个成员</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> constant1;</span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> constant2;</span><br><span class="line">   std::cout &lt;&lt; MAX_SCORE &lt;&lt; std::endl;  <span class="comment">// 报错：MAX_SCORE 不明确</span></span><br><span class="line">   std::cout &lt;&lt; constant1::MAX_SCORE &lt;&lt; std::endl; <span class="comment">// 命名空间不能省略 100</span></span><br><span class="line">   std::cout &lt;&lt; constant2::MAX_SCORE &lt;&lt; std::endl; <span class="comment">// 命名空间不能省略 150</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><blockquote>
<p>对数字类型（整型，浮点型，字符型）的数据进行运算</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">对两个数字进行相加的计算</td>
<td align="center">10 + 3 &#x3D; 13</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">对两个数字进行相减的计算</td>
<td align="center">10 - 3 &#x3D; 7</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">对两个数字进行相乘的计算</td>
<td align="center">10 * 3 &#x3D; 30</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">对两个数字进行相除的计算</td>
<td align="center">10 &#x2F; 3 &#x3D; 3</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">对两个数字进行求模的计算（求余数）</td>
<td align="center">10 % 3 &#x3D; 1</td>
</tr>
<tr>
<td align="center">++x</td>
<td align="center">前自增：x先进行+1，再进行运算</td>
<td align="center">y &#x3D; ++x;x &#x3D; x+1，y &#x3D; x + 1</td>
</tr>
<tr>
<td align="center">x++</td>
<td align="center">后自增：再进行运算，x先进行+1</td>
<td align="center">y &#x3D; x++;y &#x3D; x,x &#x3D; x + 1</td>
</tr>
<tr>
<td align="center">–x</td>
<td align="center">前自减：x先进行-1，再进行运算</td>
<td align="center">y &#x3D; –x;x &#x3D; x-1，y &#x3D; x - 1</td>
</tr>
<tr>
<td align="center">x–</td>
<td align="center">后自增：再进行运算，x先进行-1</td>
<td align="center">y &#x3D; x–;y &#x3D; x,x &#x3D; x - 1</td>
</tr>
</tbody></table>
<blockquote>
<p>注意事项：</p>
<ol>
<li>整型与整型计算的结果，还是一个整型，所以如果10&#x2F;3，得到的结果是浮点型3.33333，此时系统会将这个数字强制类型转换成整型的结果，<wavy>舍去小数点后面的所有数字</wavy>，只保留整数部分3</li>
<li>在进行计算的时候，结果会进行类型提升，<wavy>将结果提升为取值氛围大的数据类型</wavy><ul>
<li>int 与 int 的计算结果是 int</li>
<li>int 与 long 的计算结果是 long</li>
<li>float 与 long 的计算结果是 float</li>
<li>float 与 double 的计算结果是 double</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>,x = <span class="number">0</span>;</span><br><span class="line">   y = x++;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt;  y &lt;&lt; <span class="string">&quot;;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// y = 0;x = 1</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>,x = <span class="number">0</span>;</span><br><span class="line">   y = ++x;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt;  y &lt;&lt; <span class="string">&quot;;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// y = 1;x = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><blockquote>
<p>将等号<code>=</code>右边的值赋给左边的变量<br>下面表格的前提：int num &#x3D; 10;</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">示例</th>
<th align="center">运算结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">num &#x3D; 10</td>
<td align="center">(num &#x3D; 10)  &#x3D;&gt;  10</td>
</tr>
<tr>
<td align="center">+&#x3D;</td>
<td align="center">num +&#x3D; 10</td>
<td align="center">num &#x3D; (int)(num +10)</td>
</tr>
<tr>
<td align="center">-&#x3D;</td>
<td align="center">num -&#x3D; 10</td>
<td align="center">num &#x3D; (int)(num -10)</td>
</tr>
<tr>
<td align="center">*&#x3D;</td>
<td align="center">num *&#x3D; 10</td>
<td align="center">num &#x3D; (int)(num *10)</td>
</tr>
<tr>
<td align="center">&#x2F;&#x3D;</td>
<td align="center">num &#x2F;&#x3D; 10</td>
<td align="center">num &#x3D; (int)(num &#x2F;10)</td>
</tr>
<tr>
<td align="center">%&#x3D;</td>
<td align="center">num %&#x3D; 10</td>
<td align="center">num &#x3D; (int)(num %10)</td>
</tr>
</tbody></table>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><blockquote>
<p>对两个变量进行大小关系的比较，最后比较的结果一定是布尔类型的</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">示例</th>
<th align="center">运算结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td align="center">10 &lt; 20</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">10 &gt; 20</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">10 &lt;&#x3D; 20</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">10 &gt;&#x3D; 20</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">10 &#x3D;&#x3D; 20</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">10 !&#x3D; 20</td>
<td align="center">true</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><blockquote>
<p>对两个布尔类型的变量进行的逻辑操作</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="left">描述</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="left">与运算，两边为真即为真，任意一个为假，结果即为假</td>
<td align="center">true &amp; true  &#x3D;&gt;  true</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">或运算，两边为假即为假，任意一个为真，结果即为真</td>
<td align="center">true | false  &#x3D;&gt;  true</td>
</tr>
<tr>
<td align="center">!</td>
<td align="left">非运算，非真即假，非假及真</td>
<td align="center">!true  &#x3D;&gt;  false</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">异或运算，相同为假，不同为真</td>
<td align="center">true  ^  true  &#x3D;&gt;  false</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td align="left">短路与，左边的结果为假，右边的表达式不参与运算</td>
<td align="center">false &amp;&amp; true  &#x3D;&gt;  true</td>
</tr>
<tr>
<td align="center">||</td>
<td align="left">短路或，左边的结果为真，右边的表达式不参与运算</td>
<td align="center">true || false  &#x3D;&gt;  true</td>
</tr>
</tbody></table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><blockquote>
<p>作用于两个整数数字的运算，将参与运算的每一个数字计算出补码，对补码中的每一位进行类似于逻辑运算的操作，1相当于True，0相当于False</p>
</blockquote>
<div class="note red anzhiyufont anzhiyu-icon-dengpao simple"><ul>
<li>原码：十进制数据的二进制表现形式，最左边为符号位，0为正，1为负</li>
<li>反码：正数的反码是本身，负数的反码在原码的基础上，符号位不变。数值取反，0变1，1变0</li>
<li>补码：正数的补码是本身，负数的补码在反码的基础上+1</li>
</ul>
</div>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">位与运算</td>
<td align="center">10  &amp;  20</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">位或运算</td>
<td align="center">10  &amp;  20</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">位异或运算</td>
<td align="center">10  &amp;  20</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">按位取反运算</td>
<td align="center">~10</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">位左移运算</td>
<td align="center">10  &lt;&lt;  1  &#x3D;&gt; 10 * 2</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">位右移运算</td>
<td align="center">10  &gt;&gt;  1  &#x3D;&gt; 10 &#x2F; 2</td>
</tr>
</tbody></table>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><blockquote>
<p>语法：<code>condition（条件）</code> <code>？</code> <code>value1</code> <code>:</code> <code>value2</code><br><code>condition</code>：是一个bool类型的变量或者bool类型运算结果的表达式<br> 运算逻辑：如果<code>condition</code>的值是true,三目运算符的结果取value1，否则取value2</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> age = <span class="number">22</span>;</span><br><span class="line">   std::cout &lt;&lt; (age &gt;= <span class="number">18</span> ? <span class="string">&quot;已成年&quot;</span> : <span class="string">&quot;未成年&quot;</span>) &lt;&lt; std::endl; <span class="comment">// 已成年</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><blockquote>
<p>代码从上往下，依次执行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="number">20</span> &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="number">30</span> &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="number">40</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="comment">// 输出： 10  20  30  40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><blockquote>
<p>程序在某一个节点遇到了多种执行的可能性，根据条件，选择一个分支继续执行</p>
</blockquote>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><blockquote>
<p><code>if else</code> 语句：可用于变量的区间范围进行判断，根据结果选择分支继续执行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断<span class="number">1</span> <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>)&#123;</span><br><span class="line">   <span class="comment">// 条件判断1结果为true，执行该括号内的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(条件判断<span class="number">1</span> <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>) &#123;</span><br><span class="line">   <span class="comment">// 条件判断1结果为false，条件判断2结果为true，执行该括号内的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 条件判断2结果为false，执行该括号内的代码</span></span><br><span class="line">&#125;....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果if 或 else if 或 else 后面的括号中有且只有一条语句，此时括号可以省略</span></span><br><span class="line"><span class="keyword">if</span>(条件判断<span class="number">1</span> <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>) </span><br><span class="line">   <span class="comment">// 条件判断1结果为true，执行该条语句</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件判断<span class="number">1</span> <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line">   <span class="comment">// 条件判断1结果为false，条件判断2结果为true，执行该括号内的代码</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">// 条件判断2结果为false，执行该括号内的代码</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> age = <span class="number">22</span>;</span><br><span class="line">   <span class="keyword">if</span>( age &gt;= <span class="number">16</span> &amp;&amp; age &lt;= <span class="number">18</span> )&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;青少年&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>( age &gt;<span class="number">18</span> )&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;成年人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;年龄错误！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> age = <span class="number">22</span>;</span><br><span class="line">   <span class="keyword">if</span>( age &gt;= <span class="number">16</span> &amp;&amp; age &lt;= <span class="number">18</span> )</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;青少年&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( age &gt;<span class="number">18</span> )</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;成年人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;年龄错误！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><blockquote>
<p><code>switch case</code>语句：用于多重分支且条件判断是等值（固定特定值）判断的情况</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">switch</span>(variable)&#123;</span><br><span class="line">      <span class="keyword">case</span> const1:</span><br><span class="line">         <span class="comment">// variable == const1,执行该代码段</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> const1:</span><br><span class="line">         <span class="comment">// variable == const2,执行该代码段</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="comment">// variable 没有匹配的值，则执行该代码段</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>variable：确定的<code>字符</code>或<code>整数</code>值</li>
<li>case：值只能是<code>字符</code>或<code>整数</code>的字面量，不能是变量，值不允许重复</li>
<li>break：表示<code>跳出/结束</code>，结束switch语句</li>
<li>default：所有情况都不匹配，执行该处的内容，可以写在任意位置，也可以省略不写</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">123</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;春天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">456</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;夏天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">789</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;秋天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101112</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;冬天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;没有该季节！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 输出：春天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch case 语句中的的<code>穿透性</code>：</p>
<ul>
<li>当switch的变量和某一个case的值匹配上之后，将会跳过后续的case或者default的匹配，直接向后穿透</li>
<li>为了避免switch的穿透性，每一个case和default可以使用<code>break</code>，来跳出switch语句</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">456</span>;</span><br><span class="line">    <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">123</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;春天&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">456</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;夏天&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">789</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;秋天&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101112</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;冬天&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;没有该季节！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 输出：夏天  秋天  冬天  没有该季节！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然也可以利用switch的穿透性实现特定的功能</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;春天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;夏天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;秋天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;冬天&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;没有该季节！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 输出：夏天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><blockquote>
<p>某段代码需要被重复执行多次并且遵循一定规律，则使用循环结构</p>
</blockquote>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)&#123;</span><br><span class="line">   <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>条件表达式：循环终止的判断条件语句，结果为bool类型的表达式</li>
<li>循环体：n行循环要执行的语句</li>
</ul>
</blockquote>
<blockquote>
<p>流程说明：</p>
<ol>
<li>执行条件表达式，也就是执行循环是否终止的判断条件，表达式的值如果是false，则循环结束，如果是true，循环继续执行</li>
<li>执行循环语句，大括号中的代码，需要循环的代码</li>
<li>回到第一步再次执行，直到表达式的结果为false，while循环才会结束</li>
</ol>
</blockquote>
<blockquote>
<p>注意事项</p>
<ol>
<li>while循环本身没有循环变量的声明和初始化的部分，应在while循环前声明循环变量并赋值</li>
<li>while循环本身也没有控制循环终止的判断条件语句部分，所以需要再循环体中增加相应的控制语句，否则容易死循环</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 循环变量声明和初始化</span></span><br><span class="line">   <span class="keyword">while</span>(i &lt;= <span class="number">5</span>)&#123; <span class="comment">// 循环条件</span></span><br><span class="line">      <span class="comment">// 循环体</span></span><br><span class="line">      std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      i++; <span class="comment">// 更新循环变量</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例：需要在控制台上输入一个整型数字，如果用户在控制台上输入的不正确，让用户重复输入，直到输入正确为止</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个整数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="keyword">while</span>(cin.<span class="built_in">fail</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入错误，请重新输入：&quot;</span>;</span><br><span class="line">        cin.<span class="built_in">clear</span>();</span><br><span class="line">        cin.<span class="built_in">ignore</span>(numeric_limits&lt; streamsize &gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流程说明</p>
<ol>
<li>先执行循环体中的语句</li>
<li>执行条件表达式（循环终止的条件判断语句），结果如果为<code>true</code>，继续执行，如果是<code>false</code>，则循环结束</li>
<li>回到第一步，再次执行，直到条件表达式的结果为<code>false</code></li>
</ol>
</blockquote>
<blockquote>
<p>注意事项</p>
<ul>
<li>do-while循环为先执行后判断，先执行一次循环体中的代码，然后再执行条件表达式，所以do-while循环至少执行一次</li>
<li>其他特点跟while循环一样</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化部分</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 循环体</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 循环变量更新</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(count &lt; <span class="number">3</span>); <span class="comment">// 循环条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环起点;循环条件;循环步长)&#123;</span><br><span class="line">   <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>循环起点：循环变量的<code>初始化</code>，如 int i &#x3D; 0</li>
<li>循环条件：循环<code>终止</code>的条件，为布尔表达式， 如 i &lt; 10</li>
<li>循环步长：循环改变的控制条件语句，如 i++</li>
<li>循环体：循环要执行的语句</li>
<li>表达式之间要用分号<code>;</code>分隔</li>
</ul>
</blockquote>
<blockquote>
<p>流程说明</p>
<ol>
<li>第一步：执行循环变量初始化语句（循环起点）</li>
<li>第二步：执行循环终止的判断条件表达式，结果为<code>ture</code>，继续执行第三步，结果为<code>false</code>，结束循环</li>
<li>第三步：执行循环语句</li>
<li>第四步：执行循环步长，也就是循环改变的控制条件语句，使循环变量的值发生改变</li>
<li>第五步：回到第二步，再次执行执行第二步到第五步，直到第二步的循环条件的表达式结果为<code>false</code>，循环结束</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;当前循环变量的值：&quot;</span> &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 输出： 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>for循环的小括号中每一个部分都可以省略不写,但是分号<code>;</code>不能省略</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">      cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制的关键字"><a href="#流程控制的关键字" class="headerlink" title="流程控制的关键字"></a>流程控制的关键字</h3><blockquote>
<p><code>break</code>：</p>
<ul>
<li>用于终止某个语句块的执行</li>
<li>如果是在循环中，则是跳出所在的循环，如果是在switch语句中，则为跳出所在的switch语句</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">6</span>)&#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>continue</code>：</p>
<ul>
<li>跳过本次循环，执行下一次循环，（如果有多次循环，默认继续执行离自己最近的循环）提前终止本次循环</li>
<li>只能在循环语句中使用</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">6</span>)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 输出：1 2 3 4 5 7 8 9 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>goto</code>：</p>
<ul>
<li>可以在任意的位置设置<code>标签</code>,使用关键字<code>goto</code>可以直接跳转到指定的<code>标签</code>的位置继续执行</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    label1:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">goto</span> label3;</span><br><span class="line"></span><br><span class="line">    label2:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    label3:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出：1 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote>
<p>函数是一个可以多次使用的功能代码块</p>
</blockquote>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line">返回值类型 函数名(参数列表)&#123; <span class="comment">// 形参</span></span><br><span class="line">   函数体</span><br><span class="line">   <span class="keyword">return</span> 返回值 <span class="comment">// 有返回值则必须返回，没有则不用返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line">函数名(参数列表) <span class="comment">// 实参</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>返回值：表示函数执行的结果，无返回值为<code>void</code>，有返回值就为对应的数据类型,<code>return</code>返回函数执行后的结果，并结束函数的执行</li>
<li>函数名：遵循标识符的命名规则</li>
<li>参数列表：定义若干个<code>参数</code>的部分，(参数类型 参数名1,参数类型 参数名2,参数类型，参数名3……)</li>
<li>函数体：函数的<code>功能</code>实现部分</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取两数最大的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">max</span>(<span class="number">10</span>,<span class="number">20</span>); </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl; <span class="comment">//  输出：20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项</p>
<ul>
<li>函数不能嵌套</li>
<li>函数不调用，函数就不会被执行</li>
<li>函数定义写在<code>main</code>方法前面，但可以提前声明变量名</li>
<li>函数的执行会压到栈中去执行：<code>先进先出</code>，先调用的函数，在栈的底部存放，而新调用的函数，会在栈的顶部存放，程序先处理栈顶的函数中的逻辑</li>
<li>函数的调用：如果函数定义有参数列表，则调用时，<code>参数个数</code>和<code>参数类型</code>必须一致，调用时必须为每个参数赋值</li>
<li>形参：在定义函数的时候，小括号中定义的参数，由于这样的参数只有形式上的定义，并没有具体的值，因此被称为形式</li>
<li>实参：在调用函数的时候，小括号中定义的参数，由于这样的参数，位形参提供了确切的值，因此将这样的参数叫做<code>实际参数</code></li>
<li>传参：在调用的函数的时候，用实参给形参赋值，这样的过程叫做<code>传参</code></li>
<li>参数可以使用<code>const</code>来修饰，表示参数的值不允许<code>修改</code>的</li>
<li>在定义函数的时候，可以给参数一个默认值，但该参数要放到参数列表的<code>末尾</code>，传参时可以赋值，也可以不赋值</li>
</ul>
</blockquote>
<h2 id="函数的重载-OverLoad"><a href="#函数的重载-OverLoad" class="headerlink" title="函数的重载 OverLoad"></a>函数的重载 OverLoad</h2><blockquote>
<p>在一个类中的多个函数，<code>函数名相同</code>，<code>参数列表不同</code>(类型和数量不同)，则这两个函数就构成了重载关系</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span> num3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2 + num3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1,<span class="type">double</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 调用的是add(int,int)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 调用的是add(int,int,int)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2.3</span>) &lt;&lt; endl; <span class="comment">// 调用的是add(int,double)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h2><blockquote>
<ul>
<li>递归：一种程序设计的思想，在解决问题的时候，可以将问题拆分成若干个小问题，这些小问题的解决方式，与大的问题解决方式相同，通过解决这些小问题，逐渐解决这个大问题</li>
<li>由于涉及到方法的循环调用，因此容易出现<code>死递归</code>的情况，即所有的方法调用没有出口，只能将方法压栈执行，但是无法结束方法，因此在使用递归的时候，需要设置有效的<code>出口条件</code>，<wavy>避免无穷递归</wavy></li>
<li>递进：每一次推进，计算都比上一次变得简单，直至简单到无需继续推进，就能获得结果，也叫到达出口</li>
<li>回归：基于出口的结果，逐层向上回归，一次计算每一层的结果，直至回归到最顶层</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一个数字的阶乘，参数是需要计算阶乘的数字，返回值是计算的结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 出口条件</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">multiply</span>(n - <span class="number">1</span>); <span class="comment">// 递进</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算1 + 2 + 3 + ... + n的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="built_in">sum</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用其他文件中的函数"><a href="#调用其他文件中的函数" class="headerlink" title="调用其他文件中的函数"></a>调用其他文件中的函数</h2><blockquote>
<ul>
<li><code>.cpp</code>文件中的内容是无法<code>跨文件</code>直接访问的， 若需要让某一个函数跨文件访问，需要为其定义一个<code>.h</code>文件，称为<code>头文件</code></li>
<li>在<code>头文件</code>中添加函数的<code>声明部分</code>即可，需要使用的时候，直接使用<code>#include</code>来包含指定的<code>头文件</code>即可完成</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tools.cpp文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num1 &lt; num2)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &lt; num2) </span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tools.h文件</span></span><br><span class="line"><span class="comment">// 头文件中只做声明，不做实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 导入系统头文件时，用尖括号&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span> <span class="comment">// 导入自定义头文件时，只能用双引号&quot;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl; <span class="comment">// 输出：20</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl; <span class="comment">// 输出：10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h1><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><blockquote>
<p>在程序执行的时候，会在内存中开辟一些空间，存储数据，而内存又可以分为：<code>栈区</code>,<code>堆区</code>,<code>全局区</code>,<code>代码区</code>四个区</p>
</blockquote>
<h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><blockquote>
<p>代码区存放程序编译之后生成的<code>二进制代码</code>，例如我们写的函数就是存储在这。PS；函数在程序编译后，存储于<code>代码区</code>，调用函数时，会压到<code>栈区</code>执行其中的代码</p>
</blockquote>
<h3 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h3><blockquote>
<p>全局区内的变量在程序<code>编译</code>阶段已经<code>分配好内存空间</code>并<code>初始化</code>，这块内存在程序的整个运行期间都会存在，主要存放<code>静态变量</code>，<code>全局变量</code>，<code>全局常量</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="type">int</span> g_num1 = <span class="number">100</span>; </span><br><span class="line"><span class="comment">// 定义全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_num2 = <span class="number">100</span>; </span><br><span class="line"><span class="comment">// 定义全局静态变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_num3 = <span class="number">100</span>; </span><br><span class="line"><span class="comment">// 定义全局静态常量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> g_num4 = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 定义局部变量</span></span><br><span class="line">   <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">// 定义局部常量</span></span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">// 定义局部静态变量</span></span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> mum3 = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">// 定义局部静态常量</span></span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num4 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// &amp;:取地址符，获取数据的内存地址</span></span><br><span class="line">   cout &lt;&lt; &amp;g_num1 &lt;&lt; endl;  <span class="comment">// 全局区</span></span><br><span class="line">   cout &lt;&lt; &amp;g_num2 &lt;&lt; endl;  <span class="comment">// 全局区</span></span><br><span class="line">   cout &lt;&lt; &amp;g_num3 &lt;&lt; endl;  <span class="comment">// 全局区</span></span><br><span class="line">   cout &lt;&lt; &amp;g_num4 &lt;&lt; endl;  <span class="comment">// 全局区</span></span><br><span class="line">   </span><br><span class="line">   cout &lt;&lt; &amp;num1 &lt;&lt; endl;  <span class="comment">// 栈区</span></span><br><span class="line">   cout &lt;&lt; &amp;num2 &lt;&lt; endl;  <span class="comment">// 栈区</span></span><br><span class="line">   cout &lt;&lt; &amp;num3 &lt;&lt; endl;  <span class="comment">// 全局区</span></span><br><span class="line">   cout &lt;&lt; &amp;num4 &lt;&lt; endl;  <span class="comment">// 全局区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><blockquote>
<p>栈区由<code>系统</code>进行的内存管理，主要存放<code>函数的参数</code>以及<code>局部变量</code>，在函数完成执行，系统会自<code>动释放栈区</code>的内存，不需要用户管理</p>
</blockquote>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><blockquote>
<p> 堆区就是通过<code>new</code>、<code>malloc</code>、<code>realloc</code>分配的内存块，由<code>程序员</code>手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序执行期间，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。</p>
</blockquote>
<h3 id="内存中的数据残留"><a href="#内存中的数据残留" class="headerlink" title="内存中的数据残留"></a>内存中的数据残留</h3><blockquote>
<p>所谓的<code>删除数据</code>，删除的只是你对指定地址范围空间的<code>使用权</code>，你不能够再去使用这块空间了，但是这块空间中原来的内容是不会被删除掉的！</p>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<ul>
<li>定义变量就是在<code>内存</code>中开辟了一块指定大小的空间，空间开辟的大小取决于不同的<code>数据类型</code>所占用的空间大小。并且可以在这样的空间中进行值的赋值</li>
<li>指针：每一个开辟中的内存空间，都是有一个<code>唯一</code>的<code>地址</code>的，而这样的地址我们就称为是<code>指针</code></li>
<li><code>&amp;</code>：取地址操作符，取出变量的<code>内存地址</code></li>
<li><code>*</code>：间接寻址符：返回变量所指定地址的变量的<code>值</code></li>
</ul>
</blockquote>
<h3 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3><blockquote>
<p>定义：<code>数据类型``*</code> <code>指针名</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明了一个普通变量 a</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="comment">//声明一个指针变量，指向变量 a 的地址</span></span><br><span class="line"><span class="type">int</span>* pa;</span><br><span class="line"><span class="comment">//通过取地址符&amp;，获取 a 的地址，赋值给指针变量</span></span><br><span class="line">pa = &amp;a;</span><br><span class="line"><span class="comment">//通过间接寻址符，获取指针指向的内容</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *pa);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指针的类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="type">int</span>*    pi;</span><br><span class="line">    <span class="type">short</span>*  ps;</span><br><span class="line">    <span class="type">long</span>*   pl;</span><br><span class="line">    <span class="type">float</span>*  pf;</span><br><span class="line">    <span class="type">double</span>* pd;</span><br><span class="line">    <span class="type">char</span>*   pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>明明都是地址，为什么区分指针类型？因为<wavy>不同类型的指针±整数所跳过的字节数不同</wavy></li>
<li><code>int*</code>类型的指针 + 1 是跳过<code>四</code>个字节</li>
<li><code>double*</code>类型的指针 + 1 是跳过<code>八</code>个字节</li>
<li><code>char*</code>类型的指针 + 1 是跳过<code>一</code>个字节</li>
<li><code>指针</code> ± <code>整数</code>；是指针向前&#x2F;向后移动的<code>大小</code>（指针指向变量类型大小 * 整数）</li>
<li><code>指针</code> - <code>指针</code>：结果是两个指针之间所隔的<code>元素个数</code>，这种操作通常用于计算数组中两个元素之间的<code>距离</code>。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>指针的作用就是通过<code>地址</code>取访问指针指向的<code>变量</code>。</li>
<li>指针的类型决定了指针解引用能够访问的<code>字节数</code>。</li>
<li>例如上面的 <code>int*</code>类型的指针能访问四个字节，<code>double*</code>类型的指针可以访问八个字节，<code>char*</code>类型的指针能够访问一个字节</li>
</ul>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><blockquote>
<p>空指针：指的是没有存储任何内存地址的<code>指针变量</code>，一般使用<code>NULL</code>来表示一个空的地址。通常情况下，使用空指针可以对指针变量进行<code>初始化</code>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的指针变量p没有存储任何的地址，就是一个空指针。</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;		</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为NULL的指针变量，存储的地址其实是0，但是地址0到255的内存为系统内存，不允许访问</span></span><br><span class="line"><span class="comment">// 因此这里会出现“读取访问权限”的问题</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><blockquote>
<p>野指针：指针中存储有一个内存地址，但是这个地址指向的空间已经不存在了，这样的指针称为野指针</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里定义了一个指针变量，随便写了一个地址，这个地址对应的空间极有可能是不存在的</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="number">0x1234</span>;</span><br><span class="line"><span class="comment">// 访问野指针，也是会出现问题的</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><ul>
<li><code>const</code>放在<code>*</code>之前，表示常量指针，即常量的指针</li>
<li>指针的指向是可以修改的，但是不能通过指针来修改指向<code>空间的值</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const放在*之前，表示常量指针，即常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;num1;</span><br><span class="line">p1 = &amp;num2;</span><br><span class="line"><span class="comment">// 指针的指向是可以修改的，但是不能通过指针来修改指向空间的值</span></span><br><span class="line"><span class="comment">// *p1 = 200;</span></span><br></pre></td></tr></table></figure>

<h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><ul>
<li><code>const</code>放在<code>*</code>之后，表示指针常量，即指针是一个常量值</li>
<li>可以通过指针来修改指向空间的值，但是不能修改指针的<code>地址指向</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const放在*之后，表示指针常量，即这个指针是一个常量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p2 = &amp;num1;</span><br><span class="line"><span class="comment">// 可以通过指针修改指向空间的值，但是指针的指向是不可以修改的</span></span><br><span class="line"><span class="comment">// p2 = &amp;num2;</span></span><br><span class="line">*p2 = <span class="number">300</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">interchange</span><span class="params">(<span class="type">int</span>* n1,<span class="type">int</span>* n2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *n1;</span><br><span class="line">    *n1 = *n2;</span><br><span class="line">    *n2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">interchange</span>(&amp;a,&amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<ul>
<li>变量名实质上是一段连续内存空间的别名</li>
<li>引用可以作为一个已定义变量的<code>别名</code>，通过这个别名和原来的名字都能够找到这份数据</li>
<li>定义：<code>数据类型</code> <code>&amp;</code> <code>引用名</code></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出： a = 100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="comment">// 输出：b = 100</span></span><br><span class="line">    cout &lt;&lt; &amp;a == &amp;b &lt;&lt; endl; <span class="comment">// 输出：1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<ul>
<li><code>&amp;</code>在此不是求地址运算，而是起<code>标识</code>作用</li>
<li>类型标识符是指<code>目标变量</code>的类型</li>
<li>引用必须在定义的同时<code>初始化</code>，并且以后也要从一而终，不能再引用其它数据，有点类似于 <code>const</code>变量</li>
<li>引用初始化之后不能改变</li>
<li>不能有<code>NULL</code>引用。必须确保引用是和一块合法的存储单元关联</li>
<li>可以建立对<code>数组</code>的引用</li>
</ul>
</blockquote>
<h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><blockquote>
<p>所谓的引用，其实本质来讲就是一个<code>指针常量</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个整型的变量n</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义n的引用</span></span><br><span class="line">    <span class="type">int</span>&amp; a = n; </span><br><span class="line">    <span class="comment">// 这里相当于是 int* const rn = &amp;a;</span></span><br><span class="line">    <span class="comment">// 这也就解释通了为什么rn和a引用的同一块空间，并且为什么rn不能修改引用</span></span><br><span class="line">    <span class="type">int</span>&amp; rn = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在通过引用进行空间访问的时候，系统会自动的转换成 *rn = 200;</span></span><br><span class="line">    rn = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><blockquote>
<p>常量引用，就是对一个常量建立引用，又称为<code>常引用</code>。主要用在函数的形参部分，访问误操作导致在函数题中通过形参，修改实参的值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里会出问题</span></span><br><span class="line">    <span class="comment">// n = 200;</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote>
<p>数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）<br>数组：是一个数据容器，可以存储一个固定大小的<code>相同类型</code>元素的顺序<code>集合</code></p>
</blockquote>
<blockquote>
<p>特征：</p>
<ul>
<li>数组可以用来存储任意数据类型的数据，但是所有的数据需要是<code>相同</code>的数据类型</li>
<li>数组是一个定长的容器，一旦初始化完成，长度将<code>不能改变</code></li>
<li>数组中的元素被存储在一段<code>连续</code>的内存空间中</li>
<li><code>元素</code>: 数组中存储的每一个数据，称为数组中的元素</li>
<li><code>长度</code>: 数组的容量，即数组中可以存储多少个元素</li>
<li><code>遍历</code>: 依次获取数组中的每一个元素</li>
</ul>
</blockquote>
<h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><blockquote>
<ul>
<li><code>数据类型</code> <code>数组名</code>[<code>数组长度</code>]</li>
<li><code>数据类型</code> <code>数组名</code>[<code>数组长度</code>] &#x3D; {元素1，元素2，元素3……}</li>
<li><code>数据类型</code> <code>数组名</code>[] &#x3D; {元素1，元素2，元素3……}</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义指定长度的数组，此时数组中填充的元素是不安全的</span></span><br><span class="line"><span class="type">int</span> array1[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义指定长度的数组，并使用默认的值来填充</span></span><br><span class="line"><span class="type">int</span> array2[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;		<span class="comment">// 定义一个存储int类型元素的数组，填充10个初始的值。</span></span><br><span class="line"><span class="type">int</span> array3[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;		<span class="comment">// 如果大括号中的初始的元素数量小于数组长度，剩余的元素填充默认值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义一个数组，指定数组中的元素，此时数组的长度由初始元素的数量来决定</span></span><br><span class="line"><span class="type">int</span> array4[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><blockquote>
<p>数组的访问：<br>为了能够区分数组中存储的每一个元素，在数组中存储的每一个元素都有一个唯一的<code>序号</code>，称为 <code>下标</code>。我们在访问数组中的元素的时候，通过下标来访问。</p>
<ul>
<li>注意事项: 数组中元素的下标是从<code>0</code>开始的！即数组中的元素下标范围是 <code>[0, 数组长度-1]</code></li>
<li>访问：<code>数组名</code>[<code>下标</code>]</li>
<li>修改：<code>数组名</code>[<code>下标</code>] &#x3D; 值</li>
<li><code>sizeof()</code>：返回一个对象或者类型所占的<code>内存字节数</code></li>
<li>注意事项: 通过下标访问数组元素的时候，<wavy>注意不要越界！</wavy></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">int</span> array[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问下标为5的元素</span></span><br><span class="line">cout &lt;&lt; array[<span class="number">5</span>] &lt;&lt; endl;		<span class="comment">// 读取值并输出</span></span><br><span class="line">array[<span class="number">5</span>] = <span class="number">50</span>;					<span class="comment">// 修改指定下标的元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组长度的获取</span></span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组，并输出遍历到的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    cout &lt;&lt; array[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的内存分析"><a href="#数组的内存分析" class="headerlink" title="数组的内存分析"></a>数组的内存分析</h2><blockquote>
<p>数组是一个容器，在内存中进行空间开辟的时候，并不是一个整体的空间，而是开辟了若干个<code>连续</code>的空间<br>例如：int array[10]<br>这个数组的长度为10，存储的元素数据类型是int。也就是说，需要在内存中开辟连续的10个4字节空间来存储元素。<br>array表示的是数组中<code>首元素</code>的<code>内存地址</code>！</p>
</blockquote>
<blockquote>
<p>int arr[10] &#x3D; {1, 2, 3, 4, 5};</p>
<ul>
<li>arr表示的是数组中<code>首元素</code>的<code>内存地址</code>。</li>
<li>可以直接通过 <code>*arr</code> 来找到数组中的<code>首元素</code></li>
<li>后面一个元素,可以通过arr的内存地址+4来访问到，再后面的一个元素，再加一个4….<br>（为什么要加4呢？因为这个数组中存储的元素类型是int，占据4个字节空间。如果是一个short数组，那就需要+2了）</li>
<li>C++将这一个元素的内存占用空间大小作为一个<code>单位</code> 例如: int数组，一个单位就是4个字节，short数组，一个单位就是2个字节<br>在进行元素访问的时候，首元素直接通过<code>*arr</code>就可以访问<br>后面的一位元素，偏移一个单位的地址<code>*(arr + 1)</code>个单位<br>再后面的一位元素，偏移两个单位的地址<code>*(arr + 2)</code>个单位<br>再后面的一位元素，偏移三个单位的地址<code>*(arr + 3)</code>个单位<br>这就是为什么，数组中元素的下标是从0开始的</li>
<li>注意事项：当数组作为参数传递到一个函数中的时候，传递的只是<code>首元素</code>的<code>地址</code>！</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>); <span class="comment">// 数组长度</span></span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; *arr &lt;&lt; endl; <span class="comment">// 数组中第一个元素的地址</span></span><br><span class="line">    cout &lt;&lt;  *(arr + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 数组中第二个元素的地址</span></span><br><span class="line">    cout &lt;&lt;  *(arr + <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 数组中第三个元素的地址</span></span><br><span class="line">    cout &lt;&lt;  *(arr + <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 数组中第四个元素的地址</span></span><br><span class="line">    cout &lt;&lt;  *(arr + <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// 数组中第五个元素的地址</span></span><br><span class="line">    cout &lt;&lt;  *(arr + <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 数组中第六个元素的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的参数其实等价于 int* arr，只是一个指向首元素的地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray1</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算数组的长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;	<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此需要在一个函数中完成数组的遍历、排序等操作的时候，需要带上长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray2</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><h4 id="下标遍历"><a href="#下标遍历" class="headerlink" title="下标遍历"></a>下标遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算长度</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="范围遍历"><a href="#范围遍历" class="headerlink" title="范围遍历"></a>范围遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ele : arr) &#123;</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<p>开启一个循环，每轮从未排序区间选择<code>最小</code>的元素，将其放到已排序区间的<code>末尾</code></p>
</blockquote>
<blockquote>
<p>设数组的长度为<code>n</code></p>
<ol>
<li>初始状态下，所有元素未排序，即未排序（索引）区间为<code>[0,n-1]</code></li>
<li>选取区间<code>[0,n-1]</code>中的最小元素，将其与索引<code>0</code>处的元素交换。完成后，数组前 1 个元素已排序</li>
<li>选取区间<code>[1,n-1]</code>中的最小元素，将其与索引<code>1</code>处的元素交换。完成后，数组前 2 个元素已排序。</li>
<li>以此类推。经过<code>n-1</code>轮选择与交换后，数组前<code>n-1</code>个元素已排序。</li>
<li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/selectionSort.gif" alt="image-selectionSort"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 设置最小值的下标</span></span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                <span class="comment">// 找到最小值,更新下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换当前遍历的元素和记录的最小值下标位的元素</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != len<span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt;  arr[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 计算数组长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="built_in">sort</span>(array, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序之后的数组</span></span><br><span class="line">    <span class="built_in">printArray</span>(array, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p>从数组最左端开始向右遍历，依次<wavy>比较相邻元素大小</wavy>，如果<code>左元素</code> &gt; <code>右元素</code>就交换二者。遍历完成后，最大的元素会被移动到数组的<code>最右端</code></p>
</blockquote>
<blockquote>
<p>设数组的长度为<code>n</code></p>
<ol>
<li>首先，对<code>n</code>个元素执行<code>冒泡</code>，将数组的最大元素交换至正确位置。</li>
<li>接下来，对剩余<code>n-1</code>个元素执行<code>冒泡</code>，将第二大元素交换至正确位置。</li>
<li>以此类推，经过<code>n-1</code>轮<code>冒泡</code>后，前<code>n-1</code>大的元素都被交换至正确位置。</li>
<li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_sort_overview.png" alt="image-bubbleSort"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/bubbleSort.gif" alt="image-bubbleSort"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 比较相邻元素的大小</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 相邻元素交换位置</span></span><br><span class="line">                <span class="type">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != len<span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt;  arr[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 计算数组长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="built_in">sort</span>(array, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序之后的数组</span></span><br><span class="line">    <span class="built_in">printArray</span>(array, len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组元素查找"><a href="#数组元素查找" class="headerlink" title="数组元素查找"></a>数组元素查找</h3><blockquote>
<p>数组元素查找指的是从给定的一个数组中查询<code>指定元素</code>出现的<code>下标</code><br>由于需要查询的元素在指定的数组中可能出现多次，在这里我们只需要找到一个即可</p>
</blockquote>
<h4 id="顺序查询法"><a href="#顺序查询法" class="headerlink" title="顺序查询法"></a>顺序查询法</h4><blockquote>
<p>顺序查询，<wavy>就是从前往后遍历数组</wavy>，将数组中的每一个元素和需要查询的元素进行对比。如果比较结果是相同的，说明找到了需要查询的元素。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从一个数组中查询指定的元素element出现的下标</span></span><br><span class="line"><span class="comment"> * @param array 需要查询元素的数组</span></span><br><span class="line"><span class="comment"> * @param len 数组的长度</span></span><br><span class="line"><span class="comment"> * @param element 需要查找的元素</span></span><br><span class="line"><span class="comment"> * @return 元素存在的下标，如果不存在这个元素，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* array, <span class="type">int</span> len, <span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 计算数组长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中查询元素</span></span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">indexOf</span>(array, len, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分查询法"><a href="#二分查询法" class="headerlink" title="二分查询法"></a>二分查询法</h4><blockquote>
<ul>
<li>二分查询， 即利用<wavy>数组中间的位置</wavy>， 将数组分为前后两个<code>子表</code>。</li>
<li>如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表</li>
<li>重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功</li>
</ul>
</blockquote>
<blockquote>
<p>注意：二分查询， 要求数组必须是<code>排序</code>的， 否则无法使用二分查询</p>
</blockquote>
<div class="tabs" id="binarysearch"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="binarysearch-1">Step 1</button><button type="button" class="tab " data-href="binarysearch-2">Step2</button><button type="button" class="tab " data-href="binarysearch-3">Step3</button><button type="button" class="tab " data-href="binarysearch-4">Step4</button><button type="button" class="tab " data-href="binarysearch-5">Step5</button><button type="button" class="tab " data-href="binarysearch-6">Step6</button><button type="button" class="tab " data-href="binarysearch-7">Step7</button></ul><div class="tab-contents"><div class="tab-item-content active" id="binarysearch-1"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/binary_search_step1.png" alt="images_binary_search_step1"></p></div><div class="tab-item-content" id="binarysearch-2"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/binary_search_step2.png" alt="images_binary_search_step2"></p></div><div class="tab-item-content" id="binarysearch-3"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/binary_search_step3.png" alt="images_binary_search_step3"></p></div><div class="tab-item-content" id="binarysearch-4"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/binary_search_step4.png" alt="images_binary_search_step4"></p></div><div class="tab-item-content" id="binarysearch-5"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/binary_search_step5.png" alt="images_binary_search_step5"></p></div><div class="tab-item-content" id="binarysearch-6"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/binary_search_step6.png" alt="images_binary_search_step6"></p></div><div class="tab-item-content" id="binarysearch-7"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageContent/c++/binary_search_step7.png" alt="images_binary_search_step7"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从一个数组中查询指定的元素element出现的下标</span></span><br><span class="line"><span class="comment"> * @param array 需要查询元素的数组，升序排序的数组</span></span><br><span class="line"><span class="comment"> * @param len 数组的长度</span></span><br><span class="line"><span class="comment"> * @param element 需要查找的元素</span></span><br><span class="line"><span class="comment"> * @return 元素存在的下标，如果不存在这个元素，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* array, <span class="type">int</span> len, <span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义变量，确定需要查询的范围</span></span><br><span class="line">    <span class="type">int</span> minIndex = <span class="number">0</span>, maxIndex = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (minIndex &lt;= maxIndex) &#123;</span><br><span class="line">        <span class="comment">// 计算出新的中间下标</span></span><br><span class="line">        <span class="type">int</span> midIndex = (maxIndex + minIndex) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 比较中间值和需要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (array[midIndex] &gt; element) &#123;</span><br><span class="line">            <span class="comment">// 中间值比要查询的元素大，此情况说明 target 在区间 [m+1, j] 中</span></span><br><span class="line">            maxIndex = midIndex - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[midIndex] &lt; element) &#123;</span><br><span class="line">            <span class="comment">// 中间值比要查询的元素小，此情况说明 target 在区间 [i, m-1] 中</span></span><br><span class="line">            minIndex = midIndex + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 未找到目标元素，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 计算数组长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中查询元素</span></span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">indexOf</span>(array, len, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的练习"><a href="#数组的练习" class="headerlink" title="数组的练习"></a>数组的练习</h3><ol>
<li>设计一个函数，找出一个数组中最大的数字，连同所在的下标一起输出。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMaxElementAndIndex</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 空数组判断</span></span><br><span class="line">   <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;空数组，不存在最大值！&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 不是空数组，假设数组中第0个元素就是最大的</span></span><br><span class="line">   <span class="type">int</span> maxElement = array[<span class="number">0</span>], maxIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 遍历数组，依次和当前记录的最大值进行比较</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array[i] &gt; maxElement) &#123;</span><br><span class="line">           <span class="comment">// 遍历到了新的最大值</span></span><br><span class="line">           maxElement = array[i];</span><br><span class="line">           maxIndex = i;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 输出结果</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;最大值是: &quot;</span> &lt;&lt; maxElement &lt;&lt; <span class="string">&quot;, 所在的下标是: &quot;</span> &lt;&lt; maxIndex &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设计一个函数，判断一个数组是不是一个升序的数组。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkAscending</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 思路: 从前往后，依次比较两个相邻的元素，如果后面的元素比前面的小，就可以说明不是升序</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkAscending</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* array, <span class="type">int</span> maxIndex)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 递归:</span></span><br><span class="line">   <span class="keyword">if</span> (maxIndex == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> array[<span class="number">1</span>] &gt;= array[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果maxIndex位的元素大于等于maxIndex-1位的元素，并且前maxIndex-1位的元素是升序的，那么整体就是升序的</span></span><br><span class="line">   <span class="keyword">return</span> array[maxIndex] &gt;= array[maxIndex - <span class="number">1</span>] &amp;&amp; <span class="built_in">checkAscending</span>(array, maxIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设计一个函数，找出一个整型数组中的第二大的值。<ul>
<li>不可以通过排序实现，不能修改数组中的数据顺序</li>
<li>要考虑到最大的数字可能出现多次</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSecondMax</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;没有次大值&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 定义两个变量，分别用来记录最大值和次大值</span></span><br><span class="line">   <span class="type">int</span> max = array[<span class="number">0</span>], second = array[<span class="number">0</span>];</span><br><span class="line">   <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">           <span class="comment">// 新的最大值出现了，需要更新最大值和次大值</span></span><br><span class="line">           second = max;</span><br><span class="line">           max = array[i];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] &lt; max &amp;&amp; array[i] &gt; second) &#123;</span><br><span class="line">           <span class="comment">// 新的次大值出现了</span></span><br><span class="line">           second = array[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设计一个函数，将一个数组中的元素倒序排列（注意，不是降序）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 交换第0位和最后一位，第一位和倒数第二位... 交换到一半即可</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">       <span class="type">int</span> temp = array[i];</span><br><span class="line">       array[i] = array[array.length - <span class="number">1</span> - i];</span><br><span class="line">       array[array.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将一个数组中的元素拷贝到另外一个数组中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> srcLen, <span class="type">int</span>* dst, <span class="type">int</span> dstLen)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 遍历原数组，依次将元素拷贝到目标数组中</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; srcLen; i++) &#123;</span><br><span class="line">       <span class="comment">// 2. dst越界判断</span></span><br><span class="line">       <span class="keyword">if</span> (i &gt;= dstLen) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       dst[i] =  src[i];</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>设计一个函数，比较两个数组中的元素是否相同（数量、每一个元素都相同，才认为是相同的数组）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equals</span><span class="params">(<span class="type">int</span>* array1, <span class="type">int</span> arr1Len, <span class="type">int</span>* array2, <span class="type">int</span> arr2Len)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 特殊判断</span></span><br><span class="line">   <span class="keyword">if</span> (array1 == <span class="literal">NULL</span> || array2 == <span class="literal">NULL</span> || arr1Len != arr2Len) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 逐个元素进行比较</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr1Len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (array1[i] != array2[i]) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p>有时候我们对数组进行操作的时候，需要进行数组的拷贝，而此时会有<code>浅拷贝</code>和<code>深拷贝</code>两种数组的拷贝形式。</p>
<ul>
<li>浅拷贝：也就是<code>地址拷贝</code>，拷贝到的是数组的<code>首元素地址</code>。</li>
<li>深拷贝：定义一个<code>新的数组</code>，长度与原来的数组相同，<wavy>将原来数组中的每一个元素依次拷贝到新的数组中</wavy>。</li>
</ul>
<p>从上述的说明中，可以看出，所谓的浅拷贝其实就是拷贝了一个地址，得到的数组与原来的数组指向的其实是同一块空间。因此对一个数组进行的操作都会对另外一个数组产生影响。而深拷贝则不然，深拷贝是创建了一个全新的数组，虽然元素与原来的数组元素相同，但是从内存上来看的话，这是一个全新的数组，修改这个数组不会对另外一个数组产生任何影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个需要拷贝的数组</span></span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝、地址拷贝</span></span><br><span class="line">    <span class="type">int</span>* array_copy_1 = array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝，创建一个新的等长的数组，并将元素依次拷贝过来</span></span><br><span class="line">    <span class="type">int</span> array_copy_deep[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        array_copy_deep[i] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="二维数组的介绍"><a href="#二维数组的介绍" class="headerlink" title="二维数组的介绍"></a>二维数组的介绍</h4><blockquote>
<p>数组其实就是一个容器，存储着若干的数据。数组中可以存储<code>任意类型</code>的元素，可以存储<code>整数</code>、可以存储浮点<code>数字</code>、可以存储<code>字符串</code>，其实数组中也可以存储一个<code>数组</code></p>
</blockquote>
<blockquote>
<p>如果一个数组中存储的元素类型是一个<code>数组</code>，那么这样的数组就是<code>二维数组</code></p>
</blockquote>
<p>理论上讲还有三维数组、四维数组，只不过一般不去讨论。我们在讨论多维数组的时候，基本也就是指的二维数组了。</p>
<h4 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h4><p>通常我们会将二维数组比作一个<code>行列矩阵</code>，二维数组有多少元素，相当于有多少行。二维数组中的小一维数组有多少元素，相当于有多少列</p>
<blockquote>
<p>二维数组的定义：</p>
<ol>
<li>数据类型 标识符[<code>行数</code>][<code>列数</code>];</li>
<li>数据类型 标识符[<code>行数</code>][<code>列数</code>] &#x3D; { {val1, val2, val3}, {val1, val2, val3} };</li>
<li>数据类型 标识符[<code>行数</code>][<code>列数</code>] &#x3D; { val1, val2, val3, val4 };</li>
<li>数据类型 标识符[][<code>列数</code>] &#x3D; { val1, val2, val3, … };</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义二维数组:</span></span><br><span class="line">    <span class="comment">// 数据类型 标识符[行数][列数];</span></span><br><span class="line">    <span class="type">int</span> array1[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据类型 标识符[行数][列数] = &#123; &#123;val1, val2, val3&#125;, &#123;val1, val2, val3&#125; &#125;;</span></span><br><span class="line">    <span class="type">int</span> array2[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据类型 标识符[行数][列数] = &#123; val1, val2, val3, val4 &#125;;</span></span><br><span class="line">    <span class="comment">// 此时系统会将这些元素中，每5个元素组合到一起</span></span><br><span class="line">    <span class="comment">// 最后剩余到不到5个的元素，补0凑够5位拼成一个数组</span></span><br><span class="line">    <span class="type">int</span> array3[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据类型 标识符[][列数] = &#123; val1, val2, val3, ... &#125;</span></span><br><span class="line">    <span class="type">int</span> array4[][<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组的使用"><a href="#二维数组的使用" class="headerlink" title="二维数组的使用"></a>二维数组的使用</h4><p>二维数组中的元素访问与一维数组是相同的，通过下标来进行访问即可！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">2</span>][<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// 输出：1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象介绍"><a href="#面向对象介绍" class="headerlink" title="面向对象介绍"></a>面向对象介绍</h2><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><ul>
<li><strong>面向过程</strong></li>
<li>是一种看待问题、解决问题的思维方式，着眼点在于<wavy>问题是如何一步步的解决的 ，然后亲力亲为的解决问题</wavy></li>
<li><strong>面向对象</strong></li>
<li>是一种看待问题、解决问题的思维方式，着眼点在于<wavy>找到一个能够帮助解决问题的实体，然后委托这个实体来解决问题</wavy></li>
</ul>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="小明买电脑"><a href="#小明买电脑" class="headerlink" title="小明买电脑"></a>小明买电脑</h4><ul>
<li><p>面向过程</p>
<ol>
<li>(小明)去市场买配件</li>
<li>(小明)将零件运回家里</li>
<li>(小明)将电脑组装起来</li>
</ol>
</li>
<li><p>面向对象</p>
<ol>
<li>找到一个能够帮助买电脑的朋友 – 老王</li>
<li>委托老王去买电脑配件</li>
<li>委托老王把电脑运回来</li>
<li>委托老王把电脑组装起来</li>
</ol>
</li>
</ul>
<h4 id="把大象装冰箱"><a href="#把大象装冰箱" class="headerlink" title="把大象装冰箱"></a>把大象装冰箱</h4><ul>
<li><p>面向过程</p>
<ol>
<li>(我)打开冰箱门</li>
<li>(我)把大象装进冰箱</li>
<li>(我)关上冰箱门</li>
</ol>
</li>
<li><p>面向对象</p>
<ol>
<li>冰箱，开门</li>
<li>大象，进去冰箱里</li>
<li>冰箱，关门</li>
</ol>
</li>
</ul>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>在面向对象的编程思想中，着眼点在于找到一个能够帮助解决问题的实体，然后委托这个实体解决问题。</p>
<p>在这里，这个具有特定的功能，<wavy>能够解决特定问题的实体</wavy>，就是一个<code>对象</code>。</p>
<p>由若干个具有相同的特征和行为的对象的组成的<code>集合</code>，就是一个<code>类</code>。</p>
<p><code>类是对象的集合，对象是类的个体</code></p>
<h2 id="类的设计与对象的创建"><a href="#类的设计与对象的创建" class="headerlink" title="类的设计与对象的创建"></a>类的设计与对象的创建</h2><h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>从若干个具有相同的<code>特征</code>和<code>行为</code>的对象中，提取出这些相同的特征和行为，设计为一个<code>类</code></p>
<p>类中定义所有的对象共有的<code>特征</code>和<code>行为</code>，其中，特征用<code>属性</code>表示，行为用<code>方法</code>表示</p>
<p>所谓<code>属性</code>，其实就是定义在类中的一个<code>变量</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">权限修饰符:</span><br><span class="line">   成员变量;</span><br><span class="line">   成员变量;</span><br><span class="line">   成员变量;</span><br><span class="line">   ......</span><br><span class="line">   </span><br><span class="line">权限修饰符:</span><br><span class="line">   成员函数<span class="number">1</span></span><br><span class="line">   成员函数<span class="number">2</span></span><br><span class="line">   成员函数<span class="number">3</span></span><br><span class="line">   ......</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设计一个类，描述人</span></span><br><span class="line"><span class="comment">// 属性: 姓名、性别、年龄</span></span><br><span class="line"><span class="comment">// 方法: 走路、吃饭</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    string gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;人类会走路&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;人类会吃饭&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项:</p>
<ul>
<li>在类中定义的属性、方法，默认都是<code>private</code>的权限，在类外是不能访问的。如果需要在类外访问，需要修改为<code>public</code>权限。</li>
<li><code>public</code>: 在<code>任意位置</code>都可以访问</li>
<li><code>protected</code>: 在<code>当前类</code>和<code>子类</code>中可以访问</li>
<li><code>private</code>: 只能在<code>当前类</code>中访问</li>
</ul>
</blockquote>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 直接创建对象，隐式调用</span></span><br><span class="line">    Person Tom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 显式调用</span></span><br><span class="line">    Person Tom = <span class="built_in">Person</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 关键字new   </span></span><br><span class="line">    Person* Tom = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的三种创建方式中，前两种方式是类似的。我们在创建对象的时候，区别主要是有没有使用关键字new。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">使用new</th>
<th align="center">没有使用new</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存方面</td>
<td align="center">在堆空间开辟</td>
<td align="center">在栈空间开辟</td>
</tr>
<tr>
<td align="center">内存管理</td>
<td align="center">需要手动使用delete销毁</td>
<td align="center">不需要手动销毁</td>
</tr>
<tr>
<td align="center">属性初始化</td>
<td align="center">自动有默认的初始值</td>
<td align="center">没有初始值</td>
</tr>
<tr>
<td align="center">语法</td>
<td align="center">需要用类*来接收变量</td>
<td align="center">不需要使用*</td>
</tr>
<tr>
<td align="center">成员访问</td>
<td align="center">通过.访问</td>
<td align="center">通过-&gt;访问</td>
</tr>
</tbody></table>
<h3 id="成员访问"><a href="#成员访问" class="headerlink" title="成员访问"></a>成员访问</h3><p>成员访问，即访问类中的成员（<code>属性</code>、<code>方法</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Person对象</span></span><br><span class="line">    Person xiaobai;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问类中的属性</span></span><br><span class="line">    xiaobai.name = <span class="string">&quot;xiao bai&quot;</span>;</span><br><span class="line">    xiaobai.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问类中的方法</span></span><br><span class="line">    xiaobai.<span class="built_in">walk</span>();</span><br><span class="line">    xiaobai.<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用new创建对象</span></span><br><span class="line">    Person* xiaobai = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问类中的属性</span></span><br><span class="line">    xiaobai -&gt; name = <span class="string">&quot;xiao bai&quot;</span>;</span><br><span class="line">    xiaobai -&gt; age = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问类中的方法</span></span><br><span class="line">    xiaobai -&gt; <span class="built_in">walk</span>();</span><br><span class="line">    xiaobai -&gt; <span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义的数据类型-类"><a href="#自定义的数据类型-类" class="headerlink" title="自定义的数据类型(类)"></a>自定义的数据类型(类)</h3><p>我们在定义类中的属性的时候，可以定义<code>int</code>类型、<code>float</code>类型、<code>字符串</code>类型等等，那么能不能定义为另外的一个类的类型呢？</p>
<p>可以的！类其实就是一种自定义的复杂的数据类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    string color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;汪汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    string gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;人类会走路&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;人类会吃饭&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="类外和其他文件中实现类函数"><a href="#类外和其他文件中实现类函数" class="headerlink" title="类外和其他文件中实现类函数"></a>类外和其他文件中实现类函数</h3><h4 id="类外实现"><a href="#类外实现" class="headerlink" title="类外实现"></a>类外实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">()</span></span>;		<span class="comment">// 在这里只是定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;person walk&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="其他文件中实现"><a href="#其他文件中实现" class="headerlink" title="其他文件中实现"></a>其他文件中实现</h4><blockquote>
<p>  如果我们设计的类需要在其他的文件中访问，需要设计<code>头文件</code>！</p>
</blockquote>
<p><strong>person.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASIC_LEARNING_PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_LEARNING_PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>person.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;person walk&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>我们在类中定义成员的时候（函数、属性），可以使用关键字<code>static</code>来修饰，而这里的关键字<code>static</code>表示的就是<code>静态</code></p>
<p>在一个类中，被<code>static</code>修饰的成员，称为<code>静态成员</code>，可以分为: <code>静态属性</code>、<code>静态函数</code></p>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><blockquote>
<p>静态的属性内存是开辟在<code>全局区</code>的，与对象无关，<wavy>并不隶属于对象</wavy>。在程序编译的时候，就已经完成了空间的开辟与初始化的赋值操作了，并且在程序运行的整个过程中是始终保持的。</p>
</blockquote>
<blockquote>
<wavy>静态属性的空间开辟早于对象的创建</wavy>，并且静态属性不隶属于对象，<wavy>而是被所有的对象所共享的</wavy>。因此，如果你希望某一个属性是可以被所有的对象所共享的，就可以设置为静态的属性。
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> part1 &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 静态的成员变量，必须在类内定义、类外初始化赋值</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> countOfObjs;</span><br><span class="line">		<span class="comment">// 静态的常量，可以在类内定义，并同时进行初始化；也可以在类内定义、类外进行初始化</span></span><br><span class="line">		<span class="type">const</span> <span class="type">static</span> <span class="type">int</span> MIN_AGE;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> Person::countOfObjs = <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> Person::MIN_AGE = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> part1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问静态成员变量（属性）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以直接使用类来访问</span></span><br><span class="line">	Person::countOfObjs = <span class="number">20</span>;		</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 也可以通过对象来访问，但是即便使用不同的对象，访问到的空间仍然是相同的空间</span></span><br><span class="line">	Person xiaobai;</span><br><span class="line">	Person xiaohei;</span><br><span class="line">	xiaohei.countOfObjs = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; xiaobai.countOfObjs &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h4><blockquote>
<p>被关键字<code>static</code>修饰的函数就是静态函数，与静态属性类似，静态函数依然不隶属于某一个对象，而是隶属于<code>当前类</code>的。静态的函数可以使用对象来调用，也可以直接使用类来调用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> part1 &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;person test&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> part1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用类来访问</span></span><br><span class="line">	Person::<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="构造函数的介绍"><a href="#构造函数的介绍" class="headerlink" title="构造函数的介绍"></a>构造函数的介绍</h3><p>构造函数，是一个比较特殊的函数。我们在使用一个类的对象的时候，需要为其分配空间。空间分配完成之后，我们一般都会对创建的<code>对象的属性</code>进行<code>初始化</code>的操作。而这个过程就可以在构造函数中来完成了。</p>
<p>因此: 构造函数是一个函数，是在对象创建的时候触发，用来对对象的属性进行初始化的赋值操作。</p>
<h3 id="构造函数的定义"><a href="#构造函数的定义" class="headerlink" title="构造函数的定义"></a>构造函数的定义</h3><ul>
<li>构造函数的名字，必须和<code>类的名字</code>相同！</li>
<li>构造函数不能写<code>返回值</code>类型！</li>
<li>构造函数可以有不同的<code>重载</code>！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这就是一个无参的构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数执行了!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这就是一个有参的构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数执行了！参数age = &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数的使用"><a href="#构造函数的使用" class="headerlink" title="构造函数的使用"></a>构造函数的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数的定义：</span></span><br><span class="line"><span class="comment">// 1、构造函数没有返回值类型，不能写，连void都不能写</span></span><br><span class="line"><span class="comment">// 2、构造函数的名字必须与类名相同</span></span><br><span class="line"><span class="comment">// 3、构造函数可以通过不同的参数，来实现重载(Overload)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person类的无参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person类的有参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> score) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person(int, int)构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 构造函数的使用：是在创建对象的时候调用的。</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 显式调用</span></span><br><span class="line">   <span class="comment">// Person xiaoming = Person();</span></span><br><span class="line">   <span class="comment">// Person xiaoming = Person(10);</span></span><br><span class="line">   <span class="comment">// Person xiaoming = Person(10, 20);</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Person xiaoming;		// 注意事项：如果用这种缩写的方式，切记，如果使用无参构造函数的方式来创建对象，不能添加()</span></span><br><span class="line">   <span class="comment">// Person xiaoming(10);</span></span><br><span class="line">   <span class="comment">// Person xiaoming(10, 20);</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 隐式调用</span></span><br><span class="line">   <span class="comment">// Person xiaoming = &#123;&#125;;  // 这里的大括号可以省略不写</span></span><br><span class="line">   <span class="comment">// Person xiaoming = &#123;10&#125;;		</span></span><br><span class="line">   <span class="comment">// Person xiaoming = &#123;10, 20&#125;;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Person* xiaoming = new Person();</span></span><br><span class="line">   <span class="comment">// Person* xiaoming = new Person(10);</span></span><br><span class="line">   <span class="comment">// Person* xiaoming = new Person(10, 20);</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h3><p>C++提供了关键字<code>explicit</code>，禁止通过构造函数进行的<code>隐式转换</code>。声明为<code>explicit</code>的构造函数不能在隐式转换中使用。</p>
<blockquote>
<p>用来修饰构造函数的<code>修饰符</code>，表示无法通过隐式调用来访问这个构造函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里创建对象会出错，因为一个参数的构造函数已经被修饰为了explicit，不允许隐式转换。</span></span><br><span class="line">    Person xiaoming = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数注意事项"><a href="#构造函数注意事项" class="headerlink" title="构造函数注意事项"></a>构造函数注意事项</h3><ul>
<li>如果在一个类中，没有手动写任意的构造函数，此时系统会自动为其提供一个<code>public</code>权限的<code>无参构造函数</code></li>
<li>如果在一个类中，写了任意的一个构造函数，此时系统将不再提供默认的无参构造函数。如果需要的话，需要自己书写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person p;	<span class="comment">// 这样的对象创建会出错，因为现在Person类中，没有无参的构造函数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h3><p>我们自己书写构造函数，很大的一个用途就是对属性进行<code>初始化</code>的<code>赋值操作</code>，就像如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string gender;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 希望给属性进行初始化的赋值操作</span></span><br><span class="line">        name = <span class="string">&quot;xiaobai&quot;</span>;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        gender = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">        score = <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a, string g, <span class="type">int</span> s) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 希望给属性使用指定的值进行初始化</span></span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        gender = g;</span><br><span class="line">        score = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的代码中，无论是无参的构造函数还是有参的构造函数，我们的目的都是在创建对象的时候，为属性进行初始化的赋值操作。但是重复的这样的赋值有点麻烦，此时，C++为我们提供了初始化列表的方式，来对属性进行初始化的赋值操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string gender;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;xiaobai&quot;</span>), <span class="built_in">age</span>(<span class="number">18</span>), <span class="built_in">gender</span>(<span class="string">&quot;male&quot;</span>), <span class="built_in">score</span>(<span class="number">99</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a, string g, <span class="type">int</span> s) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a), <span class="built_in">gender</span>(g), <span class="built_in">score</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是C++中的另外一种构造函数，这个构造函数也是可以由系统自动提供的。<br>如果我们没有给一个类写拷贝构造函数，系统会自动的生成一个默认的<code>拷贝构造函数</code>，为每一个属性进行赋值。<br>如果需要在拷贝构造函数中实现自己的拷贝逻辑，需要自己书写拷贝构造函数。</p>
<p><strong>系统默认的拷贝构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在上述的Person类中，我们并没有去写拷贝构造函数，此时系统会自动的提供一个拷贝构造函数，实现对属性的赋值操作。</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 这里就是默认执行的拷贝构造函数，相当于 Person p2 = Person(p1);</span></span><br><span class="line">    <span class="comment">// 得到的对象p2的属性值与p1对象的属性值完全相同</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.name = &quot;</span> &lt;&lt; p1.name &lt;&lt; <span class="string">&quot;, p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.name = &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自己实现拷贝构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        name = p.name;</span><br><span class="line">        age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 这里就是执行的拷贝构造函数，相当于 Person p2 = Person(p1);</span></span><br><span class="line">    <span class="comment">// 得到的对象p2的属性值与p1对象的属性值完全相同</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.name = &quot;</span> &lt;&lt; p1.name &lt;&lt; <span class="string">&quot;, p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.name = &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><blockquote>
<p>我们将一个对象从空间开辟开始，到空间销毁结束，这样的过程称为是一个对象的一生，用<code>生命周期</code>来描述这样的过程。对象的生命周期的起点是<code>构造函数</code>，而对象的生命周期的终点就是<code>析构函数</code>。</p>
</blockquote>
<ul>
<li>析构函数，将会在对象被销毁之前自动调用。</li>
<li>析构函数也是可以由系统自动生成的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span>* score;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这就是Person的析构函数，析构函数只能这样书写，且不能有参数</span></span><br><span class="line">    <span class="comment">// 通常在析构函数中，我们会进行一些资源的释放，例如开辟的堆中的内存</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数执行了，表示这个对象即将被销毁了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (score != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> score;	<span class="comment">// 释放对应的堆空间</span></span><br><span class="line">            score = <span class="literal">NULL</span>;	<span class="comment">// 释放本来存储的地址，防止野指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="深拷贝与浅拷贝的问题"><a href="#深拷贝与浅拷贝的问题" class="headerlink" title="深拷贝与浅拷贝的问题"></a>深拷贝与浅拷贝的问题</h3><p>深拷贝与浅拷贝是一个老生常谈的问题，在数组的部分提到过，在面向对象部分也有这两个概念。在这里我们首先需要先区分一下什么是深拷贝，什么是浅拷贝。</p>
<p><strong>浅拷贝：</strong>在拷贝构造函数中，直接完成属性的赋值操作。</p>
<p><strong>深拷贝：</strong>在拷贝构造函数中，创建一个新的空间，使得属性中的指针指向这个新的空间。</p>
<h4 id="浅拷贝案例"><a href="#浅拷贝案例" class="headerlink" title="浅拷贝案例"></a>浅拷贝案例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span>* score;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> s) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        age = a;</span><br><span class="line">        score = <span class="keyword">new</span> <span class="built_in">int</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">// 拷贝构造函数的默认实现，是直接进行属性值的拷贝</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        score = p.score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 将score指向的堆空间销毁</span></span><br><span class="line">        <span class="keyword">if</span> (score != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> score;</span><br><span class="line">            score = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 通过拷贝构造函数，拷贝出一个新的对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在刚才的拷贝构造函数中，属性值直接进行值的拷贝，这个过程就是一个浅拷贝</span></span><br><span class="line">    <span class="comment">// 对比两个对象的score地址，完全相同</span></span><br><span class="line">    cout &lt;&lt; p1.score &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2.score &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在直接运行这个程序就会出问题了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题出现原因：</span></span><br><span class="line">    <span class="comment">// 由于现在是浅拷贝，p2的属性score和p1的属性score存储的地址是完全相同的。</span></span><br><span class="line">    <span class="comment">// main函数执行结束，p1、p2都是局部变量，需要销毁。</span></span><br><span class="line">    <span class="comment">// 先销毁p2，执行p2的析构函数，此时p2.score指向的空间被销毁了。</span></span><br><span class="line">    <span class="comment">// 再销毁p1，执行p1的析构函数，此时p1.score指向了一个已经被销毁了空间，p1.score已经是一个野指针了。会出现问题！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="深拷贝案例"><a href="#深拷贝案例" class="headerlink" title="深拷贝案例"></a>深拷贝案例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span>* score;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> s) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        age = a;</span><br><span class="line">        score = <span class="keyword">new</span> <span class="built_in">int</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">// 拷贝构造函数的默认实现，是直接进行属性值的拷贝</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里不再是简简单单的值拷贝，而是在堆上创建了一个新的空间，新空间中存储原来p的score对应的值</span></span><br><span class="line">        <span class="comment">// 然后将这个新的空间地址给score进行赋值</span></span><br><span class="line">        score = <span class="keyword">new</span> <span class="built_in">int</span>(*p.score);	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 将score指向的堆空间销毁</span></span><br><span class="line">        <span class="keyword">if</span> (score != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> score;</span><br><span class="line">            score = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 通过拷贝构造函数，拷贝出一个新的对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在刚才的拷贝构造函数中，score属性是开辟了一个新的空间的</span></span><br><span class="line">    <span class="comment">// 对比两个对象的score地址，不相同的</span></span><br><span class="line">    cout &lt;&lt; p1.score &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2.score &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对比两个对象的score指向的值，是相同的</span></span><br><span class="line">    cout &lt;&lt; *p1.score &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p2.score &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时程序执行结束前，p2.score指向的空间被销毁，与p1.score指向的空间没有关系</span></span><br><span class="line">    <span class="comment">// 因此，p1.score在进行空间销毁的时候也就不会有任何问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><h3 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h3><p>在C++中，this是一个<code>指针</code>，用来指向<code>当前的对象</code>的！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a): <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，类Person中有一个函数getAge，可以返回属性age的值。那么问题来了，一个类可以有多个对象的。而非静态的属性age是隶属于对象的。不同的对象的age，在内存中的空间肯定也是不同的。如何区分需要返回哪一个对象的age呢？</p>
<p>在一个类中，涉及到成员的访问的时候，非静态的成员访问，通常都会使用<code>this</code>指针来访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a): <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里使用this指针来访问age属性，这种写法是默认的，并且this是可以省略不写的</span></span><br><span class="line">    <span class="comment">// 那么所谓的当前对象到底是谁呢？</span></span><br><span class="line">    <span class="comment">// 最简单的理解就是: 哪个对象调用这个函数，this指针就指向谁</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="this不可省略的情况"><a href="#this不可省略的情况" class="headerlink" title="this不可省略的情况"></a>this不可省略的情况</h3><p>绝大多数的情况下，在一个类的内部，<wavy>访问当前类中的非静态成员的时候</wavy>，<code>this</code>指针都是可以省略不写的。但是有一种情况，this指针不能省略，必须要显式的写出来:</p>
<p>如果在一个函数中出现了与当前类的属性<code>同名字</code>的<code>局部变量</code>！为了区分局部变量还是属性，此时的<code>this</code>指针不能省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这个构造函数中，出现了一个局部变量age，与属性名字相同了</span></span><br><span class="line">    <span class="comment">// 于是为了区分这两个，需要使用this指针显式的指向age属性来进行访问</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="返回当前对象的函数"><a href="#返回当前对象的函数" class="headerlink" title="返回当前对象的函数"></a>返回当前对象的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="built_in">Point</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    <span class="function">Point&amp; <span class="title">add</span><span class="params">(<span class="type">int</span> deltaX, <span class="type">int</span> deltaY)</span> </span>&#123;</span><br><span class="line">        x += deltaX;</span><br><span class="line">        y += deltaY;</span><br><span class="line">        <span class="comment">// this是一个指针，用来指向当前的对象</span></span><br><span class="line">        <span class="comment">// 因此，如果需要返回当前的对象的话，就需要使用*来访问</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>在C++中，使用空指针是可以访问成员函数的，但是需要注意：不能在函数中出现<code>this</code>指针！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age): <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">testFunction01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;testFunction01执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testFunction02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;this是一个空指针&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;testFunction02执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空对象</span></span><br><span class="line">    Person* person = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数访问</span></span><br><span class="line">    person-&gt;<span class="built_in">testFunction01</span>();		<span class="comment">// 可以正常访问，因为在这个函数中没有使用到this指针</span></span><br><span class="line">    person-&gt;<span class="built_in">testFunction02</span>();		<span class="comment">// 访问出问题，因为在这个函数中使用到了this指针</span></span><br><span class="line">    person-&gt;<span class="built_in">getAge</span>();				<span class="comment">// 访问出问题，在这个函数中虽然没有写this，但是有属性的访问，默认就是用到的this</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常函数与常对象"><a href="#常函数与常对象" class="headerlink" title="常函数与常对象"></a>常函数与常对象</h3><h4 id="什么是常函数"><a href="#什么是常函数" class="headerlink" title="什么是常函数"></a>什么是常函数</h4><ul>
<li>使用关键字<code>const</code>修饰的函数，叫做常函数。</li>
<li>常函数中，不允许<code>修改</code>属性的值。</li>
<li>常函数中，不允许<code>调用</code>其他的普通函数。</li>
<li>如果想要在常函数中修改某个属性的值，需要将这个属性设置为<code>mutable</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> score;		<span class="comment">// 修饰为可变的，这个属性可以在常函数中进行修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age, <span class="type">int</span> score): <span class="built_in">name</span>(name), <span class="built_in">age</span>(age), <span class="built_in">score</span>(score) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义常函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fixPerson</span><span class="params">(string newName, <span class="type">int</span> newAge, <span class="type">int</span> newScore)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        name = newName;		<span class="comment">// 这里会出错，不允许在常函数中修改普通属性的值</span></span><br><span class="line">		age = newAge;		<span class="comment">// 这里会出错，不允许在常函数中修改普通属性的值</span></span><br><span class="line">        score = newScore;	<span class="comment">// 这里可以正常修改，因此此时的score已经被修饰为mutable</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">test</span>();		<span class="comment">// 这里会出错，不允许在常函数中调用其他的普通函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><ul>
<li>在对象创建的时候，使用<code>const</code>修饰的对象，就是常对象</li>
<li>常对象可以访问任意的属性值，但是不能修改<code>普通属性</code>的值</li>
<li>常对象可以修改<code>mutable</code>属性的值</li>
<li>常对象只能调用<code>常函数</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个常对象</span></span><br><span class="line">   <span class="function"><span class="type">const</span> Person <span class="title">person</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 使用这个常对象进行属性访问</span></span><br><span class="line">   cout &lt;&lt; person.name &lt;&lt; endl;		<span class="comment">// 可以正常访问</span></span><br><span class="line">   person.age = <span class="number">100</span>;					<span class="comment">// 不能进行修改</span></span><br><span class="line">   person.score = <span class="number">200</span>;					<span class="comment">// mutable属性，可以修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="友元是什么"><a href="#友元是什么" class="headerlink" title="友元是什么"></a>友元是什么</h3><p>类的主要特点之一是<code>数据隐藏</code>，即类的私有成员无法在类的外部(作用域之外)访问。但是，有时候需要在类的外部访问类的<code>私有成员</code>，怎么办？</p>
<p>解决方法是使用<code>友元函数</code>，友元函数是一种特权函数，C++允许这个特权函数访问私有成员</p>
<p>程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。</p>
<h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="comment">// 将全局函数作为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">gotoBed</span><span class="params">(Home* home)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string livingRoom = <span class="string">&quot;这里是客厅&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bedRoom = <span class="string">&quot;这里是卧室&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gotoBed</span><span class="params">(Home* home)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以访问公共部分</span></span><br><span class="line">    cout &lt;&lt; home-&gt;livingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 可以访问私有部分</span></span><br><span class="line">    cout &lt;&lt; home-&gt;bedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    Home home;</span><br><span class="line">    <span class="built_in">gotoBed</span>(&amp;home);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义有这样一个类，但是类中的成员是看不到的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好基友</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Home* home;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我的家</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="comment">// 将基友的visit函数作为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string livingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;home = <span class="keyword">new</span> <span class="built_in">Home</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; home-&gt;livingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; home-&gt;bedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GoodGay gay;</span><br><span class="line">    gay.<span class="built_in">visit</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Home* home;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="comment">// 友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string livingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">    home = <span class="keyword">new</span> <span class="built_in">Home</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; home-&gt;livingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; home-&gt;bedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    GoodGay gay;</span><br><span class="line">    gay.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="什么是运算符重载"><a href="#什么是运算符重载" class="headerlink" title="什么是运算符重载"></a>什么是运算符重载</h3><blockquote>
<p>运算符重载，就是对已有的运算符<wavy>重新进行定义</wavy>，赋予其另一种功能，以适应不同的数据类型。</p>
</blockquote>
<p>运算符重载(operator overloading)只是一种<wavy>语法上的方便</wavy>，也就是它只是另一种函数<code>调用</code>的方式。<br>在c++中，可以定义一个<code>处理类</code>的<code>新运算符</code>。这种定义很像一个普通的<code>函数定义</code>，只是函数的名字由关键字<code>operator</code>及其紧跟的<code>运算符</code>组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。</p>
<p><strong>语法：</strong><br>定义重载的运算符就像定义函数，只是该函数的名字是<code>operator@</code>,这里的<code>@</code>代表了被<code>重载的运算符</code>。函数的参数中参数个数取决于两个因素。</p>
<ul>
<li>运算符是一元(一个参数)的还是二元(两个参数)；</li>
<li>运算符被定义为<code>全局函数</code>(对于一元是一个参数，对于二元是两个参数)还是<code>成员函数</code>(对于一元没有参数，对于二元是一个参数-此时该类的对象用作左耳参数)</li>
</ul>
<p><strong>注意：</strong><br>有些人很容易滥用运算符重载。它确实是一个有趣的工具。但是应该注意，它仅仅是一种语法上的方便而已，是另外一种函数调用的方式。从这个角度来看，只有在能使涉及类的代码更易写，尤其是更易读时(请记住，读代码的机会比我们写代码多多了)才有理由重载运算符。如果不是这样，就改用其他更易用，更易读的方式。</p>
<h3 id="可重载的运算符"><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h3><p>几乎所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是不能改变运算符<code>优先级</code>，不能改变运算符的<code>参数个数</code>。这样的限制有意义，否则，所有这些行为产生的运算符只会混淆而不是澄清语意。</p>
<p><strong>可重载的运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">+</th>
<th align="center">-</th>
<th align="center">*</th>
<th align="center">&#x2F;</th>
<th align="center">%</th>
<th align="center">^</th>
<th align="center">&amp;</th>
<th align="center">|</th>
<th align="center">~</th>
</tr>
</thead>
<tbody><tr>
<td align="center">!</td>
<td align="center">&#x3D;</td>
<td align="center">&lt;</td>
<td align="center">&gt;</td>
<td align="center">+&#x3D;</td>
<td align="center">-&#x3D;</td>
<td align="center">*&#x3D;</td>
<td align="center">&#x2F;&#x3D;</td>
<td align="center">%&#x3D;</td>
</tr>
<tr>
<td align="center">^&#x3D;</td>
<td align="center">&amp;&#x3D;</td>
<td align="center">|&#x3D;</td>
<td align="center">&lt;&lt;</td>
<td align="center">&gt;&gt;</td>
<td align="center">&gt;&gt;&#x3D;</td>
<td align="center">&lt;&lt;&#x3D;</td>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">!&#x3D;</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">&gt;&#x3D;</td>
<td align="center">&amp;&amp;</td>
<td align="center">||</td>
<td align="center">++</td>
<td align="center">–</td>
<td align="center">-&gt;*</td>
<td align="center">‘</td>
<td align="center">-&gt;</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">()</td>
<td align="center">new</td>
<td align="center">delete</td>
<td align="center">new[]</td>
<td align="center">delete[]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>不可重载的运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">.</th>
<th align="center">::</th>
<th align="center">.*</th>
<th align="center">?:</th>
<th align="center">sizeof</th>
<th></th>
<th></th>
<th></th>
<th align="center"></th>
</tr>
</thead>
</table>
<h3 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="运算符重载: +"></a>运算符重载: +</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义属性</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义构造函数，用来初始化属性</span></span><br><span class="line">    <span class="built_in">Point</span>(): <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类内实现的运算符重载</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; p) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + p.x, y + p.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数实现运算符重载</span></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;p1.x - p2.x, p1.y - p2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">15</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Point res = p1 + p2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;res.x = &quot;</span> &lt;&lt; res.x &lt;&lt; <span class="string">&quot;, res.y = &quot;</span> &lt;&lt; res.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point res2 = p1 - p2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;res2.x = &quot;</span> &lt;&lt; res2.x &lt;&lt; <span class="string">&quot;, res2.y = &quot;</span> &lt;&lt; res2.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="运算符重载-2"><a href="#运算符重载-2" class="headerlink" title="运算符重载: ++"></a>运算符重载: ++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义属性</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义构造函数，用来初始化属性</span></span><br><span class="line">    <span class="built_in">Point</span>(): <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运算符前置，先运算、后取值</span></span><br><span class="line">    Point <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类内实现的运算符重载，运算符后置</span></span><br><span class="line">    Point <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">// 先创建一个对象，记录原来的值</span></span><br><span class="line">        Point tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 属性自增</span></span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="comment">// 返回之前记录的值</span></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>--(Point&amp; point) &#123;</span><br><span class="line">    point.x--;</span><br><span class="line">    point.y--;</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>--(Point&amp; point, <span class="type">int</span>) &#123;</span><br><span class="line">    Point tmp = point;</span><br><span class="line">    point.x--;</span><br><span class="line">    point.y--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">15</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Point res1 = ++p1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;res1.x = &quot;</span> &lt;&lt; res1.x &lt;&lt; <span class="string">&quot;, res1.y = &quot;</span> &lt;&lt; res1.y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.x = &quot;</span> &lt;&lt; p1.x &lt;&lt; <span class="string">&quot;, p1.y = &quot;</span> &lt;&lt; p1.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point res2 = p2++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;res2.x = &quot;</span> &lt;&lt; res2.x &lt;&lt; <span class="string">&quot;, res2.y = &quot;</span> &lt;&lt; res2.y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.x = &quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="string">&quot;, p2.y = &quot;</span> &lt;&lt; p2.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="运算符重载-3"><a href="#运算符重载-3" class="headerlink" title="运算符重载: &lt;&lt;"></a>运算符重载: &lt;&lt;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义属性</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义构造函数，用来初始化属性</span></span><br><span class="line">    <span class="built_in">Point</span>(): <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">privateField</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">privateField</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateField;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外定义运算符重载，全局函数</span></span><br><span class="line"><span class="comment">// 我希望在这里能够将Point类中的私有属性也拼接起来，因此需要做成友元</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;, privateField = &quot;</span> &lt;&lt; p.privateField;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1: &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="运算符重载-4"><a href="#运算符重载-4" class="headerlink" title="运算符重载: &#x3D;"></a>运算符重载: &#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(): <span class="built_in">age</span>(<span class="number">0</span>), <span class="built_in">score</span>(<span class="number">0</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; person) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        age = person.age;</span><br><span class="line">        score = person.score;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*person.p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; person) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重载赋值运算符执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        age = person.age;</span><br><span class="line">        score = person.score;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*person.p);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p1.score = <span class="number">99</span>;</span><br><span class="line">    p1.p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里，虽然是等号运算符，但是p2对象还没有完成空间开辟、实例化，那么在这里会调用拷贝构造函数，而非重载的等号运算符</span></span><br><span class="line">    Person p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改p2的属性值</span></span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    p2.score = <span class="number">100</span>;</span><br><span class="line">    p2.p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的p1已经开辟空间了，这里就会触发重载的等号运算符</span></span><br><span class="line">    p1 = p2;</span><br><span class="line">    cout &lt;&lt; p1.age &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p1.score &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p1.p &lt;&lt; <span class="string">&quot; =&gt;&quot;</span> &lt;&lt; *p1.p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2.age &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p2.score &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p2.p &lt;&lt; <span class="string">&quot; =&gt;&quot;</span> &lt;&lt; *p2.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象编程思想中，有三大特性：封装、继承、多态。</p>
<p>封装可以有广义和狭义上的概念。广义上的封装，我们可以将一些功能相近的一些类放入一个模块中。这里我们更多强调的是狭义上的封装性。</p>
<ul>
<li><p>定义:我们可以通过对具体属性的封装实现.把对成员变量的访问进行私有化,让他只能在类内部可见,通过公共的方法间接实现访问.</p>
</li>
<li><p>优点:提高了代码的安全性,复用性和可读性.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 将不希望对外提供直接访问的属性封装起来</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(): <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="type">int</span> age) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">130</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="程序中的继承"><a href="#程序中的继承" class="headerlink" title="程序中的继承"></a>程序中的继承</h3><p>在现实生活中，我们与父母有继承的关系，在java中也存在继承的思想，来提高代码的复用性、代码的拓展性。</p>
<p>程序中的继承，是类与类之间的特征和行为的一种赠予或获取。一个类可以将自己的属性和方法赠予其他的类，一个类也可以从其他的类中获取他们的属性和方法。</p>
<p>两个类之间的继承，必须满足 <strong>is a</strong> 的关系。</p>
<p>两个类之间，A类将属性和特征赠予B类。此时A类被称为是<strong>父类</strong>，B类被称为是<strong>子类</strong>，两者之间的关系是<strong>子类继承自父类</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209060920326.png" alt="image-20220906092001239"></p>
<h3 id="继承的语法"><a href="#继承的语法" class="headerlink" title="继承的语法"></a>继承的语法</h3><p>在C++中，在定义类的时候，类名后面使用冒号来定义父类。</p>
<ul>
<li>类中的所有成员都可以继承给子类，但是私有的成员，由于访问权限的限制，子类无法访问。</li>
<li>一个类在继承了其他类之后，也可以被其他类继承。</li>
<li>使用继承，可以简化代码、提高代码的复用性、提高代码的拓展性，最重要的是让类与类之间产生了继承关系，是多态的前提。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    dog.<span class="built_in">test</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承的三种方式"><a href="#继承的三种方式" class="headerlink" title="继承的三种方式"></a>继承的三种方式</h3><p>在C++中，继承有三种方式，分别是：公共继承、保护继承和私有继承。其实只是一个访问权限的问题。</p>
<ul>
<li><strong>公共继承：</strong>继承到父类中的属性，保留原本的访问权限（私有除外）</li>
<li><strong>保护继承：</strong>继承到父类中的属性，超过protected权限的部分将降为protected权限（私有除外）</li>
<li><strong>私有继承：</strong>继承到父类中的属性，访问权限都为private权限（私有除外）</li>
</ul>
<p>C++中默认使用的是私有继承！</p>
<h4 id="公共继承"><a href="#公共继承" class="headerlink" title="公共继承"></a>公共继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类，分别定义三种访问权限的属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> publicField;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedField;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateField;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义自类，公共继承</span></span><br><span class="line"><span class="comment">// 继承到的 publicField，还是public权限</span></span><br><span class="line"><span class="comment">// 继承到的 protectedField，还是protected权限</span></span><br><span class="line"><span class="comment">// privateField是私有权限的，无法继承给自类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; publicField &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; protectedField &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SubClass sc;</span><br><span class="line">    cout &lt;&lt; sc.publicField &lt;&lt; endl;		<span class="comment">// 在类外依然可以访问</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; sc.protectedField &lt;&lt; endl;	// 类外不能访问，因为这是保护权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类，分别定义三种访问权限的属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> publicField;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedField;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateField;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义自类，保护继承</span></span><br><span class="line"><span class="comment">// 继承到的 publicField，原来是public权限，现在是protected权限</span></span><br><span class="line"><span class="comment">// 继承到的 protectedField，还是protected权限</span></span><br><span class="line"><span class="comment">// privateField是私有权限的，无法继承给自类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">protected</span> BaseClass &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; publicField &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; protectedField &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SubClass sc;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; sc.publicField &lt;&lt; endl;		// 在类不能访问，因为这是保护权限</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; sc.protectedField &lt;&lt; endl;	// 类外不能访问，因为这是保护权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类，分别定义三种访问权限的属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> publicField;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedField;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateField;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义自类，私有继承</span></span><br><span class="line"><span class="comment">// 继承到的 publicField，是私有权限</span></span><br><span class="line"><span class="comment">// 继承到的 protectedField，是私有权限</span></span><br><span class="line"><span class="comment">// privateField是私有权限的，无法继承给自类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; publicField &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; protectedField &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SubClass sc;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; sc.publicField &lt;&lt; endl;		// 类外不能访问，因为这里是私有权限</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; sc.protectedField &lt;&lt; endl;	// 类外不能访问，因为这里是私有权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承中的构造和析构"><a href="#继承中的构造和析构" class="headerlink" title="继承中的构造和析构"></a>继承中的构造和析构</h3><p>子类对象在创建的时候，需要先调用父类中的构造函数，用来初始化父类部分。因此，子类对象创建的时候，先调用父类的构造函数，再调用子类自己的构造函数。</p>
<p>而析构函数的调用正好相反，先调用子类的析构函数，再调用父类的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>() &#123;</span><br><span class="line">        age = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父类中的无参构造函数调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Animal</span><span class="params">(<span class="type">int</span> age)</span>: age(age) &#123;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父类中的有参构造函数调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父类中的析构函数调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子类中的无参构造函数被调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子类中的析构函数被调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dog <span class="title">dog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从上述的代码中可以看到，子类对象在创建的时候，需要先调用父类中的构造函数来构造父类部分。这里默认是调用父类中的无参构造函数。那么问题来了：如果父类中没有无参构造函数，或者父类中的无参构造函数是私有的，怎么办？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Animal</span><span class="params">(<span class="type">int</span> age)</span>: age(age) &#123;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父类中的有参构造函数调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父类中的析构函数调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Dog</span><span class="params">(<span class="type">int</span> age)</span> : Animal(age) &#123;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子类中的无参构造函数被调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子类中的析构函数被调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dog <span class="title">dog</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="父类子类成员同名的情况"><a href="#父类子类成员同名的情况" class="headerlink" title="父类子类成员同名的情况"></a>父类子类成员同名的情况</h3><p>如果父类和子类中出现了同名字的成员（属性、函数），子类会将从父类继承到的成员隐藏起来。此时使用子类对象来访问的时候，默认访问的是子类中的成员。如果想要访问父类中的成员，需要手动指定作用域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父类中的函数showAge被调用，age = &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子类中的函数showAge被调用，age = &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    dog.age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    dog.<span class="built_in">showAge</span>();          <span class="comment">// 默认调用的是子类中的函数</span></span><br><span class="line">    dog.Animal::<span class="built_in">showAge</span>();  <span class="comment">// 如果想要调用父类中的函数，需要显式调用</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dog.age &lt;&lt; endl;            <span class="comment">// 默认访问自类中的属性age</span></span><br><span class="line">    cout &lt;&lt; dog.Animal::age &lt;&lt; endl;    <span class="comment">// 如果想要调用父类中的属性age，需要显式调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>我们可以从一个类继承，我们也可以能同时从多个类继承，这就是多继承。但是由于多继承是非常受争议的，从多个类继承可能会导致函数、变量等同名导致较多的歧义。</p>
<p>多继承会带来一些二义性的问题，如果两个基类中有同名的函数或者变量，那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类1继承的版本还是从基类2继承的版本？</p>
<p>解决方法就是显示指定调用那个基类的版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类继承Base1、Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Derived derived;</span><br><span class="line">    <span class="comment">// func1是从Base1继承来的还是从Base2继承来的？</span></span><br><span class="line">    <span class="comment">// derived.func1();</span></span><br><span class="line">    derived.<span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决歧义:显示指定调用那个基类的func1</span></span><br><span class="line">    derived.Base1::<span class="built_in">func1</span>();</span><br><span class="line">    derived.Base2::<span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>两个派生类继承同一个基类而又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石型继承。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209061112713.png" alt="image-20220906111216636" style="zoom:30%;" />

<p>这种继承所带来的问题：</p>
<ul>
<li><p>羊继承了动物的数据和函数，鸵同样继承了动物的数据和函数，当草泥马调用函数或者数据时，就会产生二义性。</p>
</li>
<li><p>草泥马继承自动物的函数和数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigBase</span>()&#123; mParam = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;BigBase::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">public</span> BigBase &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">public</span> BigBase &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Derived derived;</span><br><span class="line">    <span class="comment">// 对“func”的访问不明确</span></span><br><span class="line">    <span class="comment">// derived.func();</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; derived.mParam &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;derived.Base1::mParam:&quot;</span> &lt;&lt; derived.Base1::mParam &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;derived.Base2::mParam:&quot;</span> &lt;&lt; derived.Base2::mParam &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p>Base1，Base2采用虚继承方式继承BigBase,那么BigBase被称为虚基类。</p>
<p>通过虚继承解决了菱形继承所带来的二义性问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigBase</span>()&#123; mParam = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;BigBase::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Derived derived;</span><br><span class="line">    <span class="comment">//二义性问题解决</span></span><br><span class="line">    derived.<span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; derived.mParam &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果:12</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derived size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><h4 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h4><p>生活中的多态，是指的客观的事物在人脑中的主观体现。例如，在路上看到一只哈士奇，你可以看做是哈士奇，可以看做是狗，也可以看做是动物。主观意识上的类别，与客观存在的事物，存在 <code>is a</code> 的关系的时候，即形成了多态。</p>
<p>在程序中，一个类的引用指向另外一个类的对象，从而产生多种形态。当二者存在直接或者间接的继承关系时，父类引用指向子类的对象，即形成多态。</p>
<p>多态是面向对象三大特性之一，记住继承是多态的前提，如果类与类之间没有继承关系，也不会存在多态。</p>
<h4 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h4><p>c++支持编译时多态(静态多态)和运行时多态(动态多态)，运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。</p>
<p>静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定(动态多态,运行时多态)。</p>
<h3 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h3><p>对象可以作为自己的类或者作为它的基类的对象来使用。还能通过基类的地址来操作它。取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这种称为向上类型转换。</p>
<p>也就是说：父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal Bark&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog Bark&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类的引用指向子类的对象</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    Animal&amp; animal = dog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上转型后的对象调用父类中的函数</span></span><br><span class="line">    animal.<span class="built_in">bark</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><blockquote>
<p>  上述代码的运行结果是: Animal bark。说明执行的是父类中的bark函数，而非子类中的函数。</p>
<p>  于是现在就有一个问题出现了: 为什么？animal的引用指向的实际上是一个Dog对象，但是为什么会调用父类中的函数实现呢？</p>
</blockquote>
<p>解决这个问题，我们需要了解下绑定(捆绑,binding)概念。</p>
<blockquote>
<p>  把函数体与函数调用相联系称为绑定(捆绑，binding)</p>
</blockquote>
<p>当绑定在程序运行之前(由编译器和连接器)完成时，称为早绑定(early binding)。</p>
<p>上面的问题就是由于早绑定引起的，因为编译器在只有Animal地址时并不知道要调用的正确函数。编译是根据指向对象的指针或引用的类型来选择函数调用。这个时候由于调用函数的时候使用的是Animal类型，编译器确定了应该调用的bark是Animal::bark的，而不是真正传入的对象Dog::bark。</p>
<p>解决方法就是迟绑定(迟捆绑,动态绑定,运行时绑定，late binding)，意味着绑定要根据对象的实际类型，发生在运行。</p>
<p>C++语言要实现这种动态绑定，必须有某种机制来确定运行时对象的类型并调用合适的成员函数。对于一种编译语言，编译器并不知道实际的对象类型（编译器并不知道Animal类型的指针或引用指向的实际的对象类型）</p>
<p>C++动态多态性是通过虚函数来实现的，虚函数允许子类（派生类）重新定义父类（基类）成员函数，而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。对于特定的函数进行动态绑定，C++要求在基类中声明这个函数的时候使用virtual关键字，动态绑定也就对virtual函数起作用。</p>
<ul>
<li>为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要.</li>
<li>如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的.</li>
<li>在派生类中virtual函数的重定义称为重写(override).</li>
<li>virtual关键字只能修饰成员函数.</li>
<li>构造函数不能为虚函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将需要动态绑定的函数定义为虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal Bark&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在子类中重写虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog Bark&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Dog对象转成父类的对象</span></span><br><span class="line">    <span class="comment">// 这里是向上转型</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    Animal&amp; animal = dog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上转型后的对象调用父类中的函数</span></span><br><span class="line">    animal.<span class="built_in">bark</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态案例"><a href="#多态案例" class="headerlink" title="多态案例"></a>多态案例</h3><h4 id="未使用多态实现"><a href="#未使用多态实现" class="headerlink" title="未使用多态实现"></a>未使用多态实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SF</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SF快递为你快速发送包裹&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EMS</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;EMS快递为您发送包裹，哪里都能送到！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDL</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;JDL快递为您发送包裹，最快当日可达！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">(string company)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (company == <span class="string">&quot;SF&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">SF</span>().<span class="built_in">sendPackage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (company == <span class="string">&quot;EMS&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">EMS</span>().<span class="built_in">sendPackage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (company == <span class="string">&quot;JDL&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">JDL</span>().<span class="built_in">sendPackage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里违背了程序设计原则中的开闭原则</span></span><br><span class="line">    <span class="comment">// 开闭原则：对拓展开放、对修改关闭，意义是当有新的功能增加对时候，直接拓展模块，而不是修改现有的实现部分。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用多态实现"><a href="#使用多态实现" class="headerlink" title="使用多态实现"></a>使用多态实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快递公司类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressCompany</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendPackage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;快递公司发送包裹&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SF</span>: <span class="keyword">public</span> ExpressCompany &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SF快递为你快速发送包裹&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EMS</span>: <span class="keyword">public</span> ExpressCompany &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;EMS快递为您发送包裹，哪里都能送到！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDL</span>: <span class="keyword">public</span> ExpressCompany &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;JDL快递为您发送包裹，最快当日可达！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendPackage</span><span class="params">(ExpressCompany&amp; express)</span> </span>&#123;</span><br><span class="line">    express.<span class="built_in">sendPackage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendPackage</span>(*(<span class="keyword">new</span> SF));</span><br><span class="line">    <span class="built_in">sendPackage</span>(*(<span class="keyword">new</span> EMS));</span><br><span class="line">    <span class="built_in">sendPackage</span>(*(<span class="keyword">new</span> JDL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><p>在设计程序时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际的创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">我们可以设计一个交通工具类，提供最基础的运输的功能。我们在使用到交通工具的时候，往往并不是寻求交通工具的对象，而是寻求的交通工具子类的对象，例如公交车、例如地铁、例如共享单车等。而我们需要的其实是在这些子类中的运输功能实现。因此，父类交通工具类中的运输功能怎么去实现没有意义。</span><br></pre></td></tr></table></figure>

<p>纯虚函数使用virtual来修饰一个函数，并且实现部分直接设置为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void test() = 0;</span><br></pre></td></tr></table></figure>

<p>如果一个类中包含了纯虚函数，那么这个类也自动的编程了抽象类了。抽象类无法实例化对象，并且子类必须重写实现父类中的纯虚函数，否则子类也是抽象类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrafficTools</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义纯虚函数，此时的类是抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transport</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span>: <span class="keyword">public</span> TrafficTools &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transport</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;公交车运输乘客&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subway</span>: <span class="keyword">public</span> TrafficTools &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transport</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;地铁运输乘客&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useTrafficTools</span><span class="params">(TrafficTools&amp; trafficTools)</span> </span>&#123;</span><br><span class="line">    trafficTools.<span class="built_in">transport</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象类无法实例化对象</span></span><br><span class="line">    <span class="comment">// new TrafficTools;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">useTrafficTools</span>(*(<span class="keyword">new</span> Bus));</span><br><span class="line">    <span class="built_in">useTrafficTools</span>(*(<span class="keyword">new</span> Subway));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="纯虚函数与多继承"><a href="#纯虚函数与多继承" class="headerlink" title="纯虚函数与多继承"></a>纯虚函数与多继承</h3><p>多继承带来了一些争议，但是接口继承可以说一种毫无争议的运用了。<br>绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，c++中没有接口的概念，但是可以通过纯虚函数实现接口。</p>
<p>接口类中只有函数原型定义，没有任何数据定义。</p>
<p>多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。<br>注意:除了析构函数外，其他声明都是纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个功能集合，厨师类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cooker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buyFood</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">cook</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个功能集合，保姆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Maid</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">cook</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clean</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">wash</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使得人类同时具备这两种功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="keyword">public</span> Cooker, <span class="keyword">public</span> Maid &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对继承到的纯虚函数进行实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buyFood</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;买菜&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cook</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;做饭&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;吃饭&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;扫地&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wash</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;洗衣服&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person xiaoming;</span><br><span class="line">    xiaoming.<span class="built_in">buyFood</span>();</span><br><span class="line">    xiaoming.<span class="built_in">cook</span>();</span><br><span class="line">    xiaoming.<span class="built_in">eat</span>();</span><br><span class="line">    xiaoming.<span class="built_in">wash</span>();</span><br><span class="line">    xiaoming.<span class="built_in">clean</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>析构函数是对象生命周期的终点，在对象被销毁之前调用。在析构函数中，我们一般会进行资源的释放、空间的销毁的操作。例如，在一个类中有指向堆空间内存的指针，我们需要通过这样的指针来销毁对应的堆空间。但是，在多态中，父类的引用可以指向子类的对象，那么我们在使用父类的引用来销毁空间的话，就有可能会出现子类中引用的堆空间无法销毁的情况，造成内存泄漏。而解决方案就是为父类添加虚析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父类的析构函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        n = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子类的析构函数执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> n;</span><br><span class="line">            n = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">    <span class="comment">// 如果没有虚析构函数的话，这里通过animal来销毁空间，的确可以把Person开辟的堆空间给销毁掉</span></span><br><span class="line">    <span class="comment">// 但是，由于只会触发父类中的析构函数，因此无法将Person属性n开辟的堆空间给销毁掉，造成内存泄漏</span></span><br><span class="line">    <span class="comment">// 解决方案：将父类的析构函数作为虚析构函数，完成动态绑定</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚析构函数也可以做成纯虚析构函数，如果一个类中包含了纯虚析构函数，那么这个类依然是一个抽象类，无法实例化对象。</p>
<p>总结：</p>
<p>如果一个类的目的不是为了实现多态，仅仅是作为一个基类来使用，那么无需将析构函数设置为虚析构函数。</p>
<p>如果一个类的目的就是为了实现多态的，那么这个类的析构函数就有必要设置为虚析构函数。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体的定义与使用"><a href="#结构体的定义与使用" class="headerlink" title="结构体的定义与使用"></a>结构体的定义与使用</h3><p>在C++中，还有一种用户自定义的数据类型，结构体。结构体的定义与使用基本与类相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 结构体中定义的属性</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体中的构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>() &#123;</span><br><span class="line">        name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="type">int</span> age): <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体中的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;正在努力学习&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结构体中的析构函数</span></span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;结构体析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建结构体对象</span></span><br><span class="line">    <span class="comment">// 创建结构体对象时候的关键字struct可以省略不写</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> student;</span><br><span class="line">    <span class="comment">// 访问成员</span></span><br><span class="line">    student.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    student.age = <span class="number">18</span>;</span><br><span class="line">    student.<span class="built_in">study</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过有参构造创建结构体对象</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> <span class="built_in">xiaoming</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> xiaohei = <span class="built_in">Student</span>(<span class="string">&quot;xiaohei&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> xiaobai = &#123;<span class="string">&quot;xiaobai&quot;</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆上创建结构体对象</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span>* xiaoli = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;xiaoli&quot;</span>, <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">delete</span> xiaoli;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体与类的区别"><a href="#结构体与类的区别" class="headerlink" title="结构体与类的区别"></a>结构体与类的区别</h3><p>C++对结构体进行了很多的拓展，是的C++对结构体用于与类几乎相同的功能：可以设计属性、函数，可以设计构造、析构，甚至可以有继承，可以有多态。现在看来C++的结构体与类的区别，主要是一点：<strong>默认的访问权限不同</strong></p>
<ul>
<li>类成员默认的访问权限是private</li>
<li>结构体成员默认的访问权限是public</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="模板的介绍"><a href="#模板的介绍" class="headerlink" title="模板的介绍"></a>模板的介绍</h3><p>c++提供了函数模板(function template)。所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。</p>
<p>c++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></p>
<p>总结：<br>模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。<br>模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数模板的定义"><a href="#函数模板的定义" class="headerlink" title="函数模板的定义"></a>函数模板的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：我想要设计一个函数，实现两个int变量的值的交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需求：我想要设计一个函数，实现两个double变量的值的交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么我需要再对两个float类型的变量进行交换，是不是还需要再写一个函数呢？</span></span><br><span class="line"><span class="comment">// 需要交换的变量的类型越多，我就越需要写更多的重复的函数</span></span><br><span class="line"><span class="comment">// 而且一旦需求变更了，交换的逻辑需要做一些小小的改变。那么每一个函数我都得修改一下，非常的复杂</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 我如果能够设计一个通用的函数，能够把类型当作参数传递到这个函数中，就可以简化很多很多的工作了！</span></span><br><span class="line"><span class="comment">// 这就是函数模板！</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数模板</span></span><br><span class="line"><span class="comment">// template: 模板关键字</span></span><br><span class="line"><span class="comment">// typename: 定义虚拟类型关键字，也可以使用class</span></span><br><span class="line"><span class="comment">// T: 定义的一个虚拟的类型，在这里暂不确定是什么类型，等到调用这个函数的时候就可以确定了</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数模板的使用"><a href="#函数模板的使用" class="headerlink" title="函数模板的使用"></a>函数模板的使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">3.14</span>, y = <span class="number">0.99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 显式指定类型</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 可以自动根据实参的类型进行推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);       <span class="comment">// 这里调用的mySwap中，类型T被推导为int类型</span></span><br><span class="line">    <span class="built_in">mySwap</span>(x, y);       <span class="comment">// 这里调用的mySwap中，类型T被推导为double类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意事项: 类型推导的时候，需要保证一致性。不满足一致性无法推导。</span></span><br><span class="line">    <span class="comment">// 例如 mySwap(a, y);     </span></span><br><span class="line">    <span class="comment">// 第一个实参a是int类型，推导T的类型为int；第二个实参y是double类型，推导T的类型为double；不一致</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数模板案例"><a href="#函数模板案例" class="headerlink" title="函数模板案例"></a>函数模板案例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：定义一个模板函数，实现对一个数组中对元素进行升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T array[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[minIndex] &gt; array[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            T tmp = array[minIndex];</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：定义一个模板函数，实现将一个数组中对元素拼接成为字符串返回</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArray</span><span class="params">(T array[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; array[len - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个int[]</span></span><br><span class="line">    <span class="type">int</span> array1[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">sizeof</span>(array1) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">mySort</span>(array1, len1);</span><br><span class="line">    <span class="built_in">showArray</span>(array1, len1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个double[]</span></span><br><span class="line">    <span class="type">double</span> array2[] = &#123;<span class="number">3.14</span>, <span class="number">9.28</span>, <span class="number">3</span>, <span class="number">3.44</span>, <span class="number">-9.2</span>, <span class="number">8.22</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">sizeof</span>(array2) / <span class="built_in">sizeof</span>(<span class="type">double</span>);</span><br><span class="line">    <span class="built_in">mySort</span>(array2, len2);</span><br><span class="line">    <span class="built_in">showArray</span>(array2, len2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个char[]</span></span><br><span class="line">    <span class="type">char</span> array3[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;k&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len3 = <span class="built_in">sizeof</span>(array3) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="built_in">mySort</span>(array3, len3);</span><br><span class="line">    <span class="built_in">showArray</span>(array3, len3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数模板与普通函数"><a href="#函数模板与普通函数" class="headerlink" title="函数模板与普通函数"></a>函数模板与普通函数</h4><p>函数模板和普通函数在调用的时候，需要注意：</p>
<ul>
<li>普通函数调用，是可以发生自动的类型转换的；函数模板调用，是不可以发生自动的类型转换的</li>
<li>如果调用函数的时候，实参既可以匹配普通函数，又可以匹配函数模板，则优先匹配普通函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myPlus</span><span class="params">(<span class="type">const</span> T&amp; n1, <span class="type">const</span> T&amp; n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myPlus</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通函数，类型可以自动转换</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">myPlus</span>(n1, c);      <span class="comment">// 这里进行了类型的自动转换，c是char类型，被转型成了int类型。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数模板，类型不可以自动转换</span></span><br><span class="line">    <span class="comment">// myPlus(n1, c);         // 这里直接错误，因为这里不允许类型的转换。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果实参既可以匹配普通函数 ，又可以匹配函数参数。则优先普通函数调用。</span></span><br><span class="line">    <span class="built_in">myPlus</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h4><p>函数模板虽然很通用，但是并不是万能的，有时候也会有不适配的情况出现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; t1, <span class="type">const</span> T&amp; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 &gt; t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述的函数模板来说，如果是比较整型、浮点型甚至字符类型的数据都是没有问题的。可是如果我设置为Person类型呢？两个Person对象无法使用&gt;进行比较，这里自然也就出问题了。</p>
<p>那么如何解决这样的问题呢？</p>
<ol>
<li>重载运算符，重载&gt;运算符。</li>
<li>通过函数模板的重载来解决。</li>
</ol>
<p>函数模板的重载，就是为了解决特定类型的对象的问题，通过函数模板的重载，可以为这些特定的数据类型提供具像化的模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; t1, <span class="type">const</span> T&amp; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 &gt; t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">compare</span>&lt;Person&gt;(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2) &#123;</span><br><span class="line">    <span class="keyword">return</span> p1.age &gt; p2.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.age = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(p1, p2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h4 id="类模板的定义"><a href="#类模板的定义" class="headerlink" title="类模板的定义"></a>类模板的定义</h4><p>类模板和函数模板的定义和使用基本是一样的，如何定义函数模板，就如何定义类模板。但是类模板与函数模板还是有点区别的：</p>
<ul>
<li>类模板不能自动类型推导。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> NumberOperator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 num1;</span><br><span class="line">    T2 num2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num1 + num2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象，不能类型推导，只能自己指定类型</span></span><br><span class="line">    NumberOperator&lt;<span class="type">int</span>, <span class="type">int</span>&gt; op1;</span><br><span class="line">    op1.num1 = <span class="number">10</span>;</span><br><span class="line">    op1.num2 = <span class="number">20</span>;</span><br><span class="line">    op1.<span class="built_in">cal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    NumberOperator&lt;<span class="type">double</span>&gt; op2;</span><br><span class="line">    op2.num1 = <span class="number">3.14</span>;</span><br><span class="line">    op2.num2 = <span class="number">10</span>;</span><br><span class="line">    op2.<span class="built_in">cal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类模板做函数参数"><a href="#类模板做函数参数" class="headerlink" title="类模板做函数参数"></a>类模板做函数参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> NumberOperation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 num1;</span><br><span class="line">    T2 num2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num1 + num2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数中明确模板类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useNumberOperation</span><span class="params">(NumberOperation&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; op)</span> </span>&#123;</span><br><span class="line">    op.<span class="built_in">cal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数中使用模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useNumberOperation02</span><span class="params">(NumberOperation&lt;T1, T2&gt;&amp; op)</span> </span>&#123;</span><br><span class="line">    op.<span class="built_in">cal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数明确模板类调用</span></span><br><span class="line">    NumberOperation&lt;<span class="type">int</span>, <span class="type">int</span>&gt; op;</span><br><span class="line">    op.num1 = <span class="number">10</span>;</span><br><span class="line">    op.num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">useNumberOperation</span>(op);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数模板</span></span><br><span class="line">    <span class="built_in">useNumberOperation02</span>(op);</span><br><span class="line">    NumberOperation&lt;<span class="type">double</span>, <span class="type">int</span>&gt; op2;</span><br><span class="line">    op2.num1 = <span class="number">10.5</span>;</span><br><span class="line">    op2.num2 = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">useNumberOperation02</span>(op2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类模板继承"><a href="#类模板继承" class="headerlink" title="类模板继承"></a>类模板继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类继承模板类的时候，必须明确指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: Animal&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里继承到的arg的数据类型是int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: Animal&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里继承到的arg的数据类型是E</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="类模板中的成员函数创建时机"><a href="#类模板中的成员函数创建时机" class="headerlink" title="类模板中的成员函数创建时机"></a>类模板中的成员函数创建时机</h4><p>类模板中的成员函数在编译的时候是不会创建的，是在调用这个函数的时候创建。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;汪汪&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;呼呼&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T pet;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeBark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pet.<span class="built_in">bark</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pet.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类设计完成后，直接编译程序，发现是没有问题的。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用makeBark函数的时候，也是没有问题的，可以正常调用。</span></span><br><span class="line">    Person&lt;Dog&gt; xiaobai;</span><br><span class="line">    xiaobai.<span class="built_in">makeBark</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用makeSleep函数的时候就出问题了，不能调用了！</span></span><br><span class="line">	xiaobai.<span class="built_in">makeSleep</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原因：类模板中的成员函数是在调用的时候才会创建的！</span></span><br><span class="line">    <span class="comment">// 因为在编译的时候，只是知道有一个对象是obj，但是具体是什么类型，不知道！</span></span><br><span class="line">    <span class="comment">// 在调用makeBark的时候，创建了这个函数，而我们设置的类型是Dog类型，没有问题，可以正常执行</span></span><br><span class="line">    <span class="comment">// 在调用makeSleep的时候，创建了这个函数，判断pet的类型是Dog类型，而在Dog类中不存在sleep函数，因此就报错了。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类模板类外实现"><a href="#类模板类外实现" class="headerlink" title="类模板类外实现"></a>类模板类外实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberCalculator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n1;</span><br><span class="line">    M n2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberCalculator</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">NumberCalculator</span>(T n1, M n2);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line">NumberCalculator&lt;T, M&gt;::<span class="built_in">NumberCalculator</span>(T n1, M n2) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n1 = n1;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n2 = n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line">NumberCalculator&lt;T, M&gt;::<span class="built_in">add</span>() &#123;</span><br><span class="line">    cout &lt;&lt; n1 + n2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类模板头文件和原文件分离问题"><a href="#类模板头文件和原文件分离问题" class="headerlink" title="类模板头文件和原文件分离问题"></a>类模板头文件和原文件分离问题</h4><p>我们在写程序的时候，很多时候都是需要将类的声明和实现分开来写。将类的声明部分写到.h文件中，将类的实现部分写在.cpp文件中。在使用到这个类的时候，直接包含.h文件即可。但是，如果是一个模板类，这样做是有问题的。</p>
<p><strong>NumberCalculator.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberCalculator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n1;</span><br><span class="line">    M n2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberCalculator</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">NumberCalculator</span>(T n1, M n2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>NumberCalculator.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NumberCalculator.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line">NumberCalculator&lt;T, M&gt;::<span class="built_in">NumberCalculator</span>(T n1, M n2) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n1 = n1;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n2 = n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="type">void</span> NumberCalculator&lt;T, M&gt;::<span class="built_in">add</span>() &#123;</span><br><span class="line">    cout &lt;&lt; n1 + n2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过无参构造创建对象，没有问题</span></span><br><span class="line">    NumberCalculator&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cal1;</span><br><span class="line">    <span class="comment">// 通过有参构造创建对象，出问题了</span></span><br><span class="line">    <span class="function">NumberCalculator&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">cal2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题出现原因：</span></span><br><span class="line">    <span class="comment">// 我们虽然引入了.h文件，但是模板类中的函数是在调用的时候才会创建的，因此在编译阶段也不会管对应的.cpp文件中的实现部分。</span></span><br><span class="line">    <span class="comment">// 而到了使用到这个函数的时候，发现这个函数已经创建了，但是没有实现。因此就报错了。</span></span><br><span class="line">    <span class="comment">// 相当于我们只是在.h中声明了函数，但是并没有实现。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如何解决问题：</span></span><br><span class="line">    <span class="comment">// 1. 使用#include引入cpp文件</span></span><br><span class="line">    <span class="comment">// 2. 将类的声明和实现放到一个文件中</span></span><br><span class="line">    <span class="comment">//    这个文件我们习惯上会定义为.hpp文件，但是并不是绝对的，只是一个习惯和约定的问题。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类模板遇到友元"><a href="#类模板遇到友元" class="headerlink" title="类模板遇到友元"></a>类模板遇到友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局友元函数类外实现-03：定义类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberCalculator</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局友元函数类外实现-02：在类之前定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumberCalculator</span><span class="params">(<span class="type">const</span> NumberCalculator&lt;T, M&gt;&amp; op)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n1 = &quot;</span> &lt;&lt; op.n1 &lt;&lt; <span class="string">&quot;, n2 = &quot;</span> &lt;&lt; op.n2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberCalculator</span> &#123;</span><br><span class="line">    <span class="comment">// 全局友元函数类内实现，无需进行什么处理，直接在这里写实现即可。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    friend void printNumberCalculator(const NumberCalculator&lt;T, M&gt;&amp; op) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;n1 = &quot; &lt;&lt; op.n1 &lt;&lt; &quot;, n2 = &quot; &lt;&lt; op.n2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局友元函数类外实现—01：在函数的后面添加一对尖括号，表示一个模板函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> printNumberCalculator&lt;&gt;(<span class="type">const</span> NumberCalculator&lt;T, M&gt;&amp; op);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n1;</span><br><span class="line">    M n2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberCalculator</span>();</span><br><span class="line">    <span class="built_in">NumberCalculator</span>(T n1, M n2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line">NumberCalculator&lt;T, M&gt;::<span class="built_in">NumberCalculator</span>(T n1, M n2) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n1 = n1;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n2 = n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> M&gt;</span><br><span class="line">NumberCalculator&lt;T, M&gt;::<span class="built_in">NumberCalculator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">NumberCalculator&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">op</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printNumberCalculator</span>(op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h1><h2 id="STL概述"><a href="#STL概述" class="headerlink" title="STL概述"></a>STL概述</h2><p>长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法,让程序员的心血不止于随时间的迁移，人事异动而烟消云散，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。</p>
<p>复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。</p>
<p>为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。</p>
<h3 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h3><p>STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。</p>
<p>STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator),容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上。</p>
<h3 id="STL六大组件简介"><a href="#STL六大组件简介" class="headerlink" title="STL六大组件简介"></a>STL六大组件简介</h3><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p>
<ul>
<li><p><strong>容器：</strong>各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p>
</li>
<li><p><strong>算法：</strong>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p>
</li>
<li><p><strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p>
</li>
<li><p><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p>
</li>
<li><p><strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p>
</li>
<li><p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p>
</li>
</ul>
<p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<h3 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h3><p>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
<p>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作。程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<ul>
<li><p>高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p>
</li>
<li><p>高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</p>
</li>
<li><p>高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p>
</li>
</ul>
<h2 id="STL三大组件"><a href="#STL三大组件" class="headerlink" title="STL三大组件"></a>STL三大组件</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器，置物之所也。</p>
<p>研究数据的特定排列方式，以利于搜索或排序或其他特殊目的，这一门学科我们称为数据结构。大学信息类相关专业里面，与编程最有直接关系的学科，首推数据结构与算法。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。</p>
<p>常用的数据结构：数组(array),链表(list),tree(树)，栈(stack),队列(queue),集合(set),映射表(map),根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。</p>
<ul>
<li>序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</li>
<li>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set&#x2F;multiset容器 Map&#x2F;multimap容器</li>
</ul>
<p>容器可以嵌套容器!</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209082339044.png" alt="image-20220908233926682"></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法，问题之解法也。</p>
<p>以有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms).</p>
<p>广义而言，我们所编写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都是用来解决或大或小的逻辑问题或数学问题。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。</p>
<p>算法分为: <em><strong>质变算法</strong></em> 和 <em><strong>非质变算法</strong></em>。</p>
<ul>
<li><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
</li>
<li><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。iterator定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如何设计出两这个之间的良好的胶着剂，才是大难题。</p>
<p>迭代器的种类:</p>
<table>
<thead>
<tr>
<th>输入迭代器</th>
<th>提供对数据的只读访问</th>
<th>只读，支持++、&#x3D;&#x3D;、！&#x3D;</th>
</tr>
</thead>
<tbody><tr>
<td>输出迭代器</td>
<td>提供对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>提供读写操作，并能向前推进迭代器</td>
<td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>提供读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
</tbody></table>
<h2 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h2><h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><h4 id="string容器基本概念"><a href="#string容器基本概念" class="headerlink" title="string容器基本概念"></a>string容器基本概念</h4><p>C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类。</p>
<p><strong>C++的字符串与C语言的字符串比较</strong></p>
<ul>
<li>C语言：char* 是一个指针。</li>
<li>C++：</li>
<li>string是一个类，内部封装了char*，用来管理这个容器。</li>
<li>string类中封装了很多的功能函数，非常实用。例如：find、copy、delete、replace、insert等。</li>
<li>不用考虑内存释放和越界的问题。</li>
</ul>
<blockquote>
<p>  string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p>
</blockquote>
<h4 id="string容器常用操作"><a href="#string容器常用操作" class="headerlink" title="string容器常用操作"></a>string容器常用操作</h4><ol>
<li><p>string构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str;      </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n, <span class="type">char</span> c);<span class="comment">//使用n个字符c初始化</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string基本赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c);<span class="comment">//字符赋值给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> start, <span class="type">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string存取字符操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string拼接操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> string&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string查找和替换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string比较操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class="line"><span class="comment">大写的A比小写的a小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string子串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos)</span> <span class="type">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string插入和删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符 </span></span><br></pre></td></tr></table></figure>


</li>
<li><p>string和C语言风格字符串转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str = <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">//char* 转 string </span></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在c++中存在一个从const char到string的隐式类型转换，却不存在从一个string对象到Cstring的自动类型转换。对于string类型的字符串，可以通过cstr()函数返回string对象对应的C_string.</span><br><span class="line"> 通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char时才将其转换为C_string.</span><br></pre></td></tr></table></figure></li>
</ol>
<p>提示:<br>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">char</span>&amp; a = s[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span>&amp; b = s[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">b = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>*)s.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;pppppppppppppppppppppppp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = &#x27;1&#x27;;</span></span><br><span class="line"><span class="comment">//b = &#x27;2&#x27;;</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>*)s.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><h4 id="vector容器基本概念"><a href="#vector容器基本概念" class="headerlink" title="vector容器基本概念"></a>vector容器基本概念</h4><p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p>
<h4 id="vector容器常用操作"><a href="#vector容器常用操作" class="headerlink" title="vector容器常用操作"></a>vector容器常用操作</h4><ol>
<li><p>vector的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>; </span><br></pre></td></tr></table></figure>


</li>
<li><p>vector的常用赋值函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector  &amp;vec);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(vec);<span class="comment">// 将vec与本身的元素互换。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>vector的大小操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class="line"><span class="built_in">capacity</span>();<span class="comment">//容器的容量</span></span><br><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len);<span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>vector的数据存取操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>vector插入和删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line"><span class="built_in">push_back</span>(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h4><p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operator, <em>operator-&gt;, operator++, operator–, operator+, operator-, operator+&#x3D;, operator-&#x3D;,</em> 普通指针天生具备。Vector支持随机存取，而普通指针正有着这样的能力。所以vector提供的是随机访问迭代器(Random Access Iterators).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector提供了begin()函数，用来返回指向首元素的指针</span></span><br><span class="line"><span class="comment">// vector提供了end()函数，用来返回指向最后一位元素的下一位的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建容器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">// 向容器中添加元素</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="comment">// 使用迭代器遍历容器</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器倒序遍历容器</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">end</span>(); it != v.<span class="built_in">begin</span>();) &#123;</span><br><span class="line">    it--;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历容器，可以缩写为for循环的写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; it : v) &#123;</span><br><span class="line">    cout &lt;&lt; it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用迭代器遍历容器的过程中，可以通过指针或者是引用来修改到容器中的值</span></span><br></pre></td></tr></table></figure>



<h4 id="vector小案例"><a href="#vector小案例" class="headerlink" title="vector小案例"></a>vector小案例</h4><ol>
<li><p>巧用swap收缩内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时 通过resize改变容器大小</span></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//容量没有改变</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>reserve预留空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预先开辟空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pStart = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (pStart != &amp;v[<span class="number">0</span>])&#123;</span><br><span class="line">			pStart = &amp;v[<span class="number">0</span>];</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><h4 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h4><p>Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209090019783.png" alt="img"></p>
<p>deque容器和vector容器最大的差异，一在于deque允许对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p>
<p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p>
<h4 id="deque容器常用操作"><a href="#deque容器常用操作" class="headerlink" title="deque容器常用操作"></a>deque容器常用操作</h4><ol>
<li><p>deque构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>deque赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>deque大小操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.<span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">deque.<span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num);<span class="comment">//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num, elem); <span class="comment">//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>deque双端操作和删除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>deque数据存取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个数据。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>deque插入操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>deque删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="deque小案例"><a href="#deque小案例" class="headerlink" title="deque小案例"></a>deque小案例</h4><blockquote>
<p>  有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。<br>      1. 创建五名选手，放到vector中<br>      2. 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中<br>      3. sort算法对deque容器中分数排序，pop_back pop_front去除最高和最低分<br>      4. deque容器遍历一遍，累加分数，累加分数&#x2F;d.size()<br>      5. person.score &#x3D; 平均分</p>
</blockquote>
<h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><h4 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h4><p>stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。<br>有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209100051973.png" alt="image-20220910005106859" style="zoom:33%;" />

<p>stack是没有迭代器的：</p>
<p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。</p>
<h4 id="stack容器常用操作"><a href="#stack容器常用操作" class="headerlink" title="stack容器常用操作"></a>stack容器常用操作</h4><ol>
<li><p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>数据存取操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>大小操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断堆栈是否为空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回堆栈的大小</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h3><h4 id="queue容器基本概念"><a href="#queue容器基本概念" class="headerlink" title="queue容器基本概念"></a>queue容器基本概念</h4><p>Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209100054997.png" alt="image-20220910005436890" style="zoom:25%;" />

<p>queue容器没有迭代器：Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。</p>
<h4 id="queue容器常用操作"><a href="#queue容器常用操作" class="headerlink" title="queue容器常用操作"></a>queue容器常用操作</h4><ol>
<li><p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;T&gt; queT;<span class="comment">//queue采用模板类实现，queue对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="type">const</span> queue &amp;que);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>存取、插入、删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>大小操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回队列的大小</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h3><h4 id="list容器基本概念"><a href="#list容器基本概念" class="headerlink" title="list容器基本概念"></a>list容器基本概念</h4><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p>
<p>List和vector是两个最常被使用的容器。</p>
<p>List容器是一个双向链表。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209100102384.png" alt="image-20220910010227282" style="zoom:25%;" />

<p>采用动态存储分配，不会造成内存浪费和溢出</p>
<p>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</p>
<p>链表灵活，但是空间和时间额外耗费较大</p>
<h4 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h4><p>List容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。</p>
<p>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.<br>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p>
<h4 id="list容器常用操作"><a href="#list容器常用操作" class="headerlink" title="list容器常用操作"></a>list容器常用操作</h4><ol>
<li><p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>元素插入和删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>大小操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(num);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line"><span class="comment">// 若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">// 如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">resize</span>(num, elem);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line"><span class="comment">// 若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">// 如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>数据存取操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>反转、排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line"><span class="built_in">sort</span>(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set&#x2F;multiset容器"></a>set&#x2F;multiset容器</h3><h4 id="set-multiset容器基本概念"><a href="#set-multiset容器基本概念" class="headerlink" title="set&#x2F;multiset容器基本概念"></a>set&#x2F;multiset容器基本概念</h4><p>Set的特性是。所有元素都会根据元素的值自动被排序。Set不允许两个元素有相同的值。</p>
<p>我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.</p>
<p>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p>
<p>multiset特性及用法和set完全相同，唯一的差别在于它允许值重复。set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。</p>
<p>树的简单知识：</p>
<p>二叉树就是任何节点最多只允许有两个字节点。分别是左子结点和右子节点</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209100107605.png" alt="image-20220910010759493" style="zoom:25%;" />

<p>二叉树示意图</p>
<p>二叉搜索树，是指二叉树中的节点按照一定的规则进行排序，使得对二叉树中元素访问更加高效。二叉搜索树的放置规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值。因此从根节点一直向左走，一直到无路可走，即得到最小值，一直向右走，直至无路可走，可得到最大值。那么在二叉搜索树中找到最大元素和最小元素是非常简单的事情。下图为二叉搜索树：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209100108859.png" alt="image-20220910010824753" style="zoom:25%;" />

<p>上面我们介绍了二叉搜索树，那么当一个二叉搜索树的左子树和右子树不平衡的时候，那么搜索依据上图表示，搜索9所花费的时间要比搜索17所花费的时间要多，由于我们的输入或者经过我们插入或者删除操作，二叉树失去平衡，造成搜索效率降低。<br>所以我们有了一个平衡二叉树的概念，所谓的平衡不是指的完全平衡。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://shawn-qianfeng.oss-cn-beijing.aliyuncs.com/img/202209100109140.png" alt="image-20220910010900020" style="zoom:25%;" />

<h4 id="set-multiset容器常用操作"><a href="#set-multiset容器常用操作" class="headerlink" title="set&#x2F;multiset容器常用操作"></a>set&#x2F;multiset容器常用操作</h4><ol>
<li><p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; st;<span class="comment">//set默认构造函数：</span></span><br><span class="line">mulitset&lt;T&gt; mst; <span class="comment">//multiset默认构造函数: </span></span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set &amp;st);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>set赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set &amp;st);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>set大小操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>插入和删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(elem);<span class="comment">//删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>查找操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="built_in">count</span>(key);<span class="comment">//查找键key的元素个数</span></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="对组"><a href="#对组" class="headerlink" title="对组"></a>对组</h4><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。</p>
<p>类模板：template &lt;class T1, class T2&gt; struct pair.</p>
<p>如何创建对组?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法创建一个对组</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">pair1</span><span class="params">(string(<span class="string">&quot;name&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl; <span class="comment">//访问pair第一个值</span></span><br><span class="line">cout &lt;&lt; pair1.second &lt;&lt; endl;<span class="comment">//访问pair第二个值</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; pair2 = <span class="built_in">make_pair</span>(<span class="string">&quot;name&quot;</span>, <span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; pair2.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">//pair=赋值</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; pair3 = pair2;</span><br><span class="line">cout &lt;&lt; pair3.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair3.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h3><h4 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map&#x2F;multimap基本概念"></a>map&#x2F;multimap基本概念</h4><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p>
<p>我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p>
<p>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p>
<p>Multimap和map的操作类似，唯一区别multimap键值可重复。</p>
<p>Map和multimap都是以红黑树为底层实现机制。</p>
<h4 id="map-multimap常用操作"><a href="#map-multimap常用操作" class="headerlink" title="map&#x2F;multimap常用操作"></a>map&#x2F;multimap常用操作</h4><ol>
<li><p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT;<span class="comment">//map默认构造函数: </span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mp);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map &amp;mp);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(mp);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>大小操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>插入操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStu;</span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">inset</span>(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p>删除元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>查找操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span></span><br><span class="line"><span class="built_in">count</span>(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="multimap案例"><a href="#multimap案例" class="headerlink" title="multimap案例"></a>multimap案例</h4><p>公司今天招聘了5个员工，5名员工进入公司之后，需要指派员工在那个部门工作</p>
<p>人员信息有: 姓名 年龄 电话 工资等组成</p>
<p>通过Multimap进行信息的插入 保存 显示</p>
<p>分部门显示员工信息 显示全部员工信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//multimap 案例</span></span><br><span class="line"><span class="comment">//公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">//人员信息有: 姓名 年龄 电话 工资等组成</span></span><br><span class="line"><span class="comment">//通过 Multimap 进行信息的插入 保存 显示</span></span><br><span class="line"><span class="comment">//分部门显示员工信息 显示全部员工信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALE_DEPATMENT 1 <span class="comment">//销售部门</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVELOP_DEPATMENT 2 <span class="comment">//研发部门</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FINACIAL_DEPATMENT 3 <span class="comment">//财务部门</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALL_DEPATMENT 4 <span class="comment">//所有部门</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name; <span class="comment">//员工姓名</span></span><br><span class="line">	<span class="type">int</span> age; <span class="comment">//员工年龄</span></span><br><span class="line">	<span class="type">double</span> salary; <span class="comment">//员工工资</span></span><br><span class="line">	string tele; <span class="comment">//员工电话</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建5个员工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePerson</span><span class="params">(vector&lt;person&gt;&amp; vlist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	string seed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">		person p;</span><br><span class="line">		p.name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		p.name += seed[i];</span><br><span class="line">		p.age = <span class="built_in">rand</span>() % <span class="number">30</span> + <span class="number">20</span>;</span><br><span class="line">		p.salary = <span class="built_in">rand</span>() % <span class="number">20000</span> + <span class="number">10000</span>;</span><br><span class="line">		p.tele = <span class="string">&quot;010-8888888&quot;</span>;</span><br><span class="line">		vlist.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5名员工分配到不同的部门</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PersonByGroup</span><span class="params">(vector&lt;person&gt;&amp; vlist, multimap&lt;<span class="type">int</span>, person&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> operate = <span class="number">-1</span>; <span class="comment">//用户的操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;person&gt;::iterator it = vlist.<span class="built_in">begin</span>(); it != vlist.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;当前员工信息:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; it-&gt;salary &lt;&lt; <span class="string">&quot; 电话：&quot;</span> &lt;&lt; it-&gt;tele &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;operate);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (operate == SALE_DEPATMENT)&#123;  <span class="comment">//将该员工加入到销售部门</span></span><br><span class="line">				plist.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(SALE_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (operate == DEVELOP_DEPATMENT)&#123;</span><br><span class="line">				plist.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(DEVELOP_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (operate == FINACIAL_DEPATMENT)&#123;</span><br><span class="line">				plist.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(FINACIAL_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;operate);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;员工部门分配完毕!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;***********************************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印员工信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(multimap&lt;<span class="type">int</span>, person&gt;&amp; plist, <span class="type">int</span> myoperate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (myoperate == ALL_DEPATMENT)&#123;</span><br><span class="line">		<span class="keyword">for</span> (multimap&lt;<span class="type">int</span>, person&gt;::iterator it = plist.<span class="built_in">begin</span>(); it != plist.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; it-&gt;second.name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; it-&gt;second.age &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; it-&gt;second.salary &lt;&lt; <span class="string">&quot; 电话：&quot;</span> &lt;&lt; it-&gt;second.tele &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="type">int</span>, person&gt;::iterator it = plist.<span class="built_in">find</span>(myoperate);</span><br><span class="line">	<span class="type">int</span> depatCount = plist.<span class="built_in">count</span>(myoperate);</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (it != plist.<span class="built_in">end</span>())&#123;</span><br><span class="line">		<span class="keyword">while</span> (it != plist.<span class="built_in">end</span>() &amp;&amp; num &lt; depatCount)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; it-&gt;second.name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; it-&gt;second.age &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; it-&gt;second.salary &lt;&lt; <span class="string">&quot; 电话：&quot;</span> &lt;&lt; it-&gt;second.tele &lt;&lt; endl;</span><br><span class="line">			it++;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据用户操作显示不同部门的人员列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPersonList</span><span class="params">(multimap&lt;<span class="type">int</span>, person&gt;&amp; plist, <span class="type">int</span> myoperate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (myoperate)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">		<span class="built_in">printList</span>(plist, SALE_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">		<span class="built_in">printList</span>(plist, DEVELOP_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">		<span class="built_in">printList</span>(plist, FINACIAL_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ALL_DEPATMENT:</span><br><span class="line">		<span class="built_in">printList</span>(plist, ALL_DEPATMENT);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户操作菜单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PersonMenue</span><span class="params">(multimap&lt;<span class="type">int</span>, person&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> isexit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (flag)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">			<span class="built_in">ShowPersonList</span>(plist, SALE_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">			<span class="built_in">ShowPersonList</span>(plist, DEVELOP_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">			<span class="built_in">ShowPersonList</span>(plist, FINACIAL_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ALL_DEPATMENT:</span><br><span class="line">			<span class="built_in">ShowPersonList</span>(plist, ALL_DEPATMENT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			isexit = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;您的输入有误，请重新输入!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isexit == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;person&gt;  vlist; <span class="comment">//创建的5个员工 未分组</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, person&gt; plist; <span class="comment">//保存分组后员工信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建5个员工</span></span><br><span class="line">	<span class="built_in">CreatePerson</span>(vlist);</span><br><span class="line">	<span class="comment">//5名员工分配到不同的部门</span></span><br><span class="line">	<span class="built_in">PersonByGroup</span>(vlist, plist);</span><br><span class="line">	<span class="comment">//根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表</span></span><br><span class="line">	<span class="built_in">PersonMenue</span>(plist);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p>
<p>注意:</p>
<p>1.函数对象(仿函数)是一个类，不是一个函数。</p>
<p>2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</p>
<p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。<br>函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象是重载了函数调用符号的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		m_Num++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="comment">//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数对象超出了普通函数的概念，可以保存函数的调用状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doBusiness</span><span class="params">(MyPrint print,<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//参数1：匿名函数对象</span></span><br><span class="line">	<span class="built_in">doBusiness</span>(<span class="built_in">MyPrint</span>(),<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterThenFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一元谓词</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 vector&lt;<span class="type">int</span>&gt;::iterator it =  <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThenFive</span>());</span><br><span class="line">	 <span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	 &#123;</span><br><span class="line">		 cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 &#123;</span><br><span class="line">		 cout &lt;&lt; <span class="string">&quot;找到了: &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><p>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include。</p>
<p>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</p>
<p><em><strong>template</strong></em>&lt;<em><strong>*class*</strong>* T&gt; T plus<T>**&#x2F;&#x2F;加法仿函数</em>*<br><em><strong>template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; T minus<T>**&#x2F;&#x2F;减法仿函数</em>*<br><em><strong>template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; T multiplies<T>**&#x2F;&#x2F;乘法仿函数</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; T divides<T>**&#x2F;&#x2F;除法仿函数</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; T modulus<T>**&#x2F;&#x2F;取模仿函数</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; T negate<T>**&#x2F;&#x2F;取反仿函数</em>*</p>
<p>6个关系运算类函数对象,每一种都是二元运算。</p>
<p><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool equal_to<T>**&#x2F;&#x2F;等于</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool not_equal_to<T>**&#x2F;&#x2F;不等于</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool greater<T>**&#x2F;&#x2F;大于</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool greater_equal<T>**&#x2F;&#x2F;大于等于</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool less<T>**&#x2F;&#x2F;小于</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool less_equal<T>**&#x2F;&#x2F;小于等于</em>*</p>
<p>逻辑运算类运算函数,not为一元运算，其余为二元运算。</p>
<p><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool logical_and<T>**&#x2F;&#x2F;逻辑与</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool logical_or<T>**&#x2F;&#x2F;逻辑或</em>*<br><em><strong>*template*</strong></em>&lt;<em><strong>*class*</strong>* T&gt; bool logical_not<T>**&#x2F;&#x2F;逻辑非</em>*</p>
<p>内建函数对象举例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取反仿函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法仿函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大于仿函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数适配器bind1st bind2nd</span></span><br><span class="line"><span class="comment">//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？</span></span><br><span class="line"><span class="comment">//我们直接给函数对象绑定参数 编译阶段就会报错</span></span><br><span class="line"><span class="comment">//for_each(v.begin(), v.end(), bind2nd(myprint(),100));</span></span><br><span class="line"><span class="comment">//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function</span></span><br><span class="line"><span class="comment">//根据我们函数对象是一元函数对象 还是二元函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> :<span class="keyword">public</span> binary_function&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">void</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1 = : &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; v2 = :&quot;</span> &lt;&lt;v2  &lt;&lt; <span class="string">&quot; v1+v2 = :&quot;</span> &lt;&lt; (v1 + v2) &lt;&lt; endl;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、函数适配器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入起始值：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">MyPrint</span>(), x));</span><br><span class="line">	<span class="comment">//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//总结：  bind1st和bind2nd区别?</span></span><br><span class="line"><span class="comment">//bind1st ： 将参数绑定为函数对象的第一个参数</span></span><br><span class="line"><span class="comment">//bind2nd ： 将参数绑定为函数对象的第二个参数</span></span><br><span class="line"><span class="comment">//bind1st bind2nd将二元函数对象转为一元函数对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterThenFive</span>:<span class="keyword">public</span> unary_function&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、取反适配器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 	vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器</span></span><br><span class="line"><span class="comment">//	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器</span></span><br><span class="line">	<span class="comment">//自定义输入</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span> ( <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(),<span class="number">5</span>)));</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序  二元函数对象</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> val)&#123;cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//not1 对一元函数对象取反</span></span><br><span class="line"><span class="comment">//not2 对二元函数对象取反</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; v + v2&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数指针适配器   ptr_fun</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ptr_fun( )把一个普通的函数指针适配成函数对象</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>( <span class="built_in">ptr_fun</span>( MyPrint03 ), <span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、成员函数适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;成员函数:&quot;</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Plus100</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Age += <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint04</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt;  p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;Person&gt;v;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for_each(v.begin(), v.end(), MyPrint04);</span></span><br><span class="line">	<span class="comment">//利用 mem_fun_ref 将Person内部成员函数适配</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::ShowPerson));</span><br><span class="line"><span class="comment">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));</span></span><br><span class="line"><span class="comment">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v1;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line"></span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果容器存放的是对象指针，  那么用mem_fun</span></span><br><span class="line"><span class="comment">//如果容器中存放的是对象实体，那么用mem_fun_ref</span></span><br></pre></td></tr></table></figure>



<h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>算法主要是由头文件组成。</p>
<p>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…</p>
<p>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</p>
<p>定义了一些模板类,用以声明函数对象。</p>
<h3 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h3><h4 id="for-each遍历算法"><a href="#for-each遍历算法" class="headerlink" title="for_each遍历算法"></a>for_each遍历算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历算法 遍历容器元素</span></span><br><span class="line"><span class="comment">	@param beg 开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 结束迭代器</span></span><br><span class="line"><span class="comment">	@param _callback  函数回调或者函数对象</span></span><br><span class="line"><span class="comment">	@return 函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*template&lt;class _InIt,class _Fn1&gt; inline</span></span><br><span class="line"><span class="comment">void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	for (; _First != _Last; ++_First)</span></span><br><span class="line"><span class="comment">		_Func(*_First);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">print001</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">	v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print001</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">print02</span>&#123;</span><br><span class="line">	<span class="built_in">print02</span>()&#123;</span><br><span class="line">		mCount = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		mCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print02 p = for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.mCount &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">print03</span> : <span class="keyword">public</span> binary_function&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val,<span class="type">int</span> bindParam)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; val + bindParam &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each绑定参数输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">print03</span>(),<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="transform算法"><a href="#transform算法" class="headerlink" title="transform算法"></a>transform算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	transform算法 将指定容器区间元素搬运到另一容器中</span></span><br><span class="line"><span class="comment">	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span></span><br><span class="line"><span class="comment">	@param beg1 源容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 源容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param _cakkback 回调函数或者函数对象</span></span><br><span class="line"><span class="comment">	@return 返回目标容器迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">transform</span>(iterator beg1, iterator end1, iterator beg2, _callbakc);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform 将一个容器中的值搬运到另一个容器中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline </span></span><br><span class="line"><span class="comment">	_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)</span></span><br><span class="line"><span class="comment">	&#123;	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		for (; _First != _Last; ++_First, ++_Dest)</span></span><br><span class="line"><span class="comment">			*_Dest = _Func(*_First);</span></span><br><span class="line"><span class="comment">		return (_Dest);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline</span></span><br><span class="line"><span class="comment">	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span></span><br><span class="line"><span class="comment">	&#123;	</span></span><br><span class="line"><span class="comment">		for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)</span></span><br><span class="line"><span class="comment">			*_Dest = _Func(*_First1, *_First2);</span></span><br><span class="line"><span class="comment">		return (_Dest);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">transformTest01</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">print01</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vSource;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">		vSource.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目标容器</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//给vTarget开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(vSource.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//将vSource中的元素搬运到vTarget</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">transform</span>(vSource.<span class="built_in">begin</span>(), vSource.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">transformTest01</span>());</span><br><span class="line">	<span class="comment">//打印</span></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">print01</span>()); cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器1和容器2中的元素相加放入到第三个容器中</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">transformTest02</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vSource1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vSource2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		vSource1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目标容器</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//给vTarget开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(vSource1.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(vSource1.<span class="built_in">begin</span>(), vSource1.<span class="built_in">end</span>(), vSource2.<span class="built_in">begin</span>(),vTarget.<span class="built_in">begin</span>(), <span class="built_in">transformTest02</span>());</span><br><span class="line">	<span class="comment">//打印</span></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">print01</span>()); cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	find算法 查找元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value 查找的元素</span></span><br><span class="line"><span class="comment">	@return 返回查找元素的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">find</span>(iterator beg, iterator end, value)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	find_if算法 条件查找</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return bool 查找返回true 否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">find_if</span>(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	adjacent_find算法 查找相邻重复元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return 返回相邻元素的第一个位置的迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">adjacent_find</span>(iterator beg, iterator end, _callback);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	binary_search算法 二分查找法</span></span><br><span class="line"><span class="comment">	注意: 在无序序列中不可用</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value 查找的元素</span></span><br><span class="line"><span class="comment">	@return bool 查找返回true 否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(iterator beg, iterator end, value)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	count算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  value回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return int返回元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">count</span>(iterator beg, iterator end, value);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count_if算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@return int返回元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">count_if</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure>



<h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	merge算法 容器元素合并，并存储到另一容器中</span></span><br><span class="line"><span class="comment">	注意:两个容器必须是有序的</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">merge</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sort算法 容器元素排序</span></span><br><span class="line"><span class="comment">	@param beg 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">sort</span>(iterator beg, iterator end, _callback)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	random_shuffle算法 对指定范围内的元素随机调整次序</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(iterator beg, iterator end)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	reverse算法 反转指定范围的元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">reverse</span>(iterator beg, iterator end)</span><br></pre></td></tr></table></figure>



<h3 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	copy算法 将容器内指定范围的元素拷贝到另一容器中</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest 目标起始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">copy</span>(iterator beg, iterator end, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	replace算法 将容器内指定范围的旧元素修改为新元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param oldvalue 旧元素</span></span><br><span class="line"><span class="comment">	@param oldvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace</span>(iterator beg, iterator end, oldvalue, newvalue)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param callback函数回调或者谓词(返回Bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@param oldvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace_if</span>(iterator beg, iterator end, _callback, newvalue)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	swap算法 互换两个容器的元素</span></span><br><span class="line"><span class="comment">	@param c1容器1</span></span><br><span class="line"><span class="comment">	@param c2容器2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">swap</span>(container c1, container c2)</span><br></pre></td></tr></table></figure>



<h3 id="常用算数生成算法"><a href="#常用算数生成算法" class="headerlink" title="常用算数生成算法"></a>常用算数生成算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	accumulate算法 计算容器元素累计总和</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value累加值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">accumulate</span>(iterator beg, iterator end, value)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fill算法 向容器中添加元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param value t填充元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">fill</span>(iterator beg, iterator end, value)</span><br></pre></td></tr></table></figure>



<h3 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	set_intersection算法 求两个set集合的交集</span></span><br><span class="line"><span class="comment">	注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_intersection</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	set_union算法 求两个set集合的并集</span></span><br><span class="line"><span class="comment">	注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_union</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	set_difference算法 求两个set集合的差集</span></span><br><span class="line"><span class="comment">	注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">	@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">	@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">	@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_difference</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/avatar.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/avatar.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Zian</div><div class="post-copyright__author_desc">玄生万物，道法自然</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/10/04/c++/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/10/04/c++/')">C/C++程序设计</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/10/04/c++/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C/C++程序设计&amp;url=http://example.com/2024/10/04/c++/&amp;pic=/src/images/pageCover/c++.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Zian</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C-C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C/C++<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/src/images/pageCover/c++.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/06/01/anzhiyu%E4%B8%BB%E9%A2%98%E6%A0%87%E7%AD%BE/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageCover/Markdown.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">安知鱼主题标签 Tag Plugins</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Zian</h1><div class="author-info__desc">玄生万物，道法自然</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/renzian" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/237138265" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HelloWorld"><span class="toc-number">1.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">单行注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">2.2.</span> <span class="toc-text">多行注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">布尔型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">字符串型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">变量和常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-number">7.</span> <span class="toc-text">控制台输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">8.</span> <span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">9.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">使用语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.2.</span> <span class="toc-text">using关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.2.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.3.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.4.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.5.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.6.</span> <span class="toc-text">三目运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">11.1.</span> <span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else"><span class="toc-number">11.2.1.</span> <span class="toc-text">if-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-case"><span class="toc-number">11.2.2.</span> <span class="toc-text">switch-case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">11.3.</span> <span class="toc-text">循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">11.3.1.</span> <span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">11.3.2.</span> <span class="toc-text">do-while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">11.3.3.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.3.4.</span> <span class="toc-text">流程控制的关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">12.1.</span> <span class="toc-text">函数的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD-OverLoad"><span class="toc-number">12.2.</span> <span class="toc-text">函数的重载 OverLoad</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">12.3.</span> <span class="toc-text">函数的递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.</span> <span class="toc-text">调用其他文件中的函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">13.</span> <span class="toc-text">指针与引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">13.1.</span> <span class="toc-text">内存分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">13.1.1.</span> <span class="toc-text">内存分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-number">13.1.2.</span> <span class="toc-text">代码区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8C%BA"><span class="toc-number">13.1.3.</span> <span class="toc-text">全局区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%8C%BA"><span class="toc-number">13.1.4.</span> <span class="toc-text">栈区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-number">13.1.5.</span> <span class="toc-text">堆区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%AE%8B%E7%95%99"><span class="toc-number">13.1.6.</span> <span class="toc-text">内存中的数据残留</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">13.2.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">13.2.1.</span> <span class="toc-text">指针的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">13.2.2.</span> <span class="toc-text">空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">13.2.3.</span> <span class="toc-text">野指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="toc-number">13.2.4.</span> <span class="toc-text">常量指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">13.2.5.</span> <span class="toc-text">指针常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">13.3.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">13.3.1.</span> <span class="toc-text">引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">13.3.2.</span> <span class="toc-text">常量引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">14.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">14.1.</span> <span class="toc-text">数组的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">14.2.</span> <span class="toc-text">数组的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">14.3.</span> <span class="toc-text">数组的内存分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">14.3.1.</span> <span class="toc-text">数组的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E9%81%8D%E5%8E%86"><span class="toc-number">14.3.1.1.</span> <span class="toc-text">下标遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E9%81%8D%E5%8E%86"><span class="toc-number">14.3.1.2.</span> <span class="toc-text">范围遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">14.3.2.</span> <span class="toc-text">数组的排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">14.3.2.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">14.3.2.2.</span> <span class="toc-text">冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE"><span class="toc-number">14.3.3.</span> <span class="toc-text">数组元素查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%B3%95"><span class="toc-number">14.3.3.1.</span> <span class="toc-text">顺序查询法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E8%AF%A2%E6%B3%95"><span class="toc-number">14.3.3.2.</span> <span class="toc-text">二分查询法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="toc-number">14.3.4.</span> <span class="toc-text">数组的练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">14.3.5.</span> <span class="toc-text">浅拷贝与深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">14.3.6.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">14.3.6.1.</span> <span class="toc-text">二维数组的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">14.3.6.2.</span> <span class="toc-text">二维数组的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">14.3.6.3.</span> <span class="toc-text">二维数组的使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.1.</span> <span class="toc-text">面向对象介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">15.1.1.</span> <span class="toc-text">面向对象与面向过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">15.1.2.</span> <span class="toc-text">案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%98%8E%E4%B9%B0%E7%94%B5%E8%84%91"><span class="toc-number">15.1.2.1.</span> <span class="toc-text">小明买电脑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E5%A4%A7%E8%B1%A1%E8%A3%85%E5%86%B0%E7%AE%B1"><span class="toc-number">15.1.2.2.</span> <span class="toc-text">把大象装冰箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.1.3.</span> <span class="toc-text">类与对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">15.2.</span> <span class="toc-text">类的设计与对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">15.2.1.</span> <span class="toc-text">类的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">15.2.2.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE"><span class="toc-number">15.2.3.</span> <span class="toc-text">成员访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%B1%BB"><span class="toc-number">15.2.4.</span> <span class="toc-text">自定义的数据类型(类)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%A4%96%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%87%BD%E6%95%B0"><span class="toc-number">15.2.5.</span> <span class="toc-text">类外和其他文件中实现类函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.5.1.</span> <span class="toc-text">类外实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.5.2.</span> <span class="toc-text">其他文件中实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81"><span class="toc-number">15.2.6.</span> <span class="toc-text">静态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">15.2.6.1.</span> <span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">15.2.6.2.</span> <span class="toc-text">静态函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">15.3.</span> <span class="toc-text">构造与析构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.3.1.</span> <span class="toc-text">构造函数的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">15.3.2.</span> <span class="toc-text">构造函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">15.3.3.</span> <span class="toc-text">构造函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.3.4.</span> <span class="toc-text">explicit关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">15.3.5.</span> <span class="toc-text">构造函数注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">15.3.6.</span> <span class="toc-text">构造函数初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.7.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.8.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">15.3.9.</span> <span class="toc-text">深拷贝与浅拷贝的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%A1%88%E4%BE%8B"><span class="toc-number">15.3.9.1.</span> <span class="toc-text">浅拷贝案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%A1%88%E4%BE%8B"><span class="toc-number">15.3.9.2.</span> <span class="toc-text">深拷贝案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">15.4.</span> <span class="toc-text">this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">15.4.1.</span> <span class="toc-text">this是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E4%B8%8D%E5%8F%AF%E7%9C%81%E7%95%A5%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">15.4.2.</span> <span class="toc-text">this不可省略的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">15.4.3.</span> <span class="toc-text">返回当前对象的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">15.4.4.</span> <span class="toc-text">空指针访问成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.4.5.</span> <span class="toc-text">常函数与常对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="toc-number">15.4.5.1.</span> <span class="toc-text">什么是常函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.4.5.2.</span> <span class="toc-text">常对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">15.5.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">15.5.1.</span> <span class="toc-text">友元是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-number">15.5.2.</span> <span class="toc-text">全局函数做友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-number">15.5.3.</span> <span class="toc-text">成员函数做友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-number">15.5.4.</span> <span class="toc-text">类做友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">15.6.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">15.6.1.</span> <span class="toc-text">什么是运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.6.2.</span> <span class="toc-text">可重载的运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-1"><span class="toc-number">15.6.3.</span> <span class="toc-text">运算符重载: +</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-2"><span class="toc-number">15.6.4.</span> <span class="toc-text">运算符重载: ++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-3"><span class="toc-number">15.6.5.</span> <span class="toc-text">运算符重载: &lt;&lt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-4"><span class="toc-number">15.6.6.</span> <span class="toc-text">运算符重载: &#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">15.7.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.1.</span> <span class="toc-text">程序中的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">15.8.2.</span> <span class="toc-text">继承的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">15.8.3.</span> <span class="toc-text">继承的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.3.1.</span> <span class="toc-text">公共继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.3.2.</span> <span class="toc-text">保护继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.3.3.</span> <span class="toc-text">私有继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">15.8.4.</span> <span class="toc-text">继承中的构造和析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E5%AD%90%E7%B1%BB%E6%88%90%E5%91%98%E5%90%8C%E5%90%8D%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">15.8.5.</span> <span class="toc-text">父类子类成员同名的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.6.</span> <span class="toc-text">多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">15.8.6.1.</span> <span class="toc-text">多继承语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.6.2.</span> <span class="toc-text">菱形继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.6.3.</span> <span class="toc-text">虚继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">15.9.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">15.9.1.</span> <span class="toc-text">多态的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81"><span class="toc-number">15.9.1.1.</span> <span class="toc-text">什么是多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">15.9.1.2.</span> <span class="toc-text">多态的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%9E%8B"><span class="toc-number">15.9.2.</span> <span class="toc-text">对象转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">15.9.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B"><span class="toc-number">15.9.4.</span> <span class="toc-text">多态案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.9.4.1.</span> <span class="toc-text">未使用多态实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.9.4.2.</span> <span class="toc-text">使用多态实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">15.9.5.</span> <span class="toc-text">纯虚函数与抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">15.9.6.</span> <span class="toc-text">纯虚函数与多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">15.9.7.</span> <span class="toc-text">虚析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">15.10.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">15.10.1.</span> <span class="toc-text">结构体的定义与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.10.2.</span> <span class="toc-text">结构体与类的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">15.11.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.11.1.</span> <span class="toc-text">模板的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">15.11.2.</span> <span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">15.11.2.1.</span> <span class="toc-text">函数模板的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">15.11.2.2.</span> <span class="toc-text">函数模板的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B"><span class="toc-number">15.11.2.3.</span> <span class="toc-text">函数模板案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">15.11.2.4.</span> <span class="toc-text">函数模板与普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">15.11.2.5.</span> <span class="toc-text">函数模板的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">15.11.3.</span> <span class="toc-text">类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">15.11.3.1.</span> <span class="toc-text">类模板的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">15.11.3.2.</span> <span class="toc-text">类模板做函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF"><span class="toc-number">15.11.3.3.</span> <span class="toc-text">类模板继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">15.11.3.4.</span> <span class="toc-text">类模板中的成员函数创建时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.11.3.5.</span> <span class="toc-text">类模板类外实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E5%8E%9F%E6%96%87%E4%BB%B6%E5%88%86%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="toc-number">15.11.3.6.</span> <span class="toc-text">类模板头文件和原文件分离问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E9%81%87%E5%88%B0%E5%8F%8B%E5%85%83"><span class="toc-number">15.11.3.7.</span> <span class="toc-text">类模板遇到友元</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">16.</span> <span class="toc-text">STL标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E6%A6%82%E8%BF%B0"><span class="toc-number">16.1.</span> <span class="toc-text">STL概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.1.1.</span> <span class="toc-text">STL基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">16.1.2.</span> <span class="toc-text">STL六大组件简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E4%BC%98%E7%82%B9"><span class="toc-number">16.1.3.</span> <span class="toc-text">STL优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">16.2.</span> <span class="toc-text">STL三大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">16.2.1.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">16.2.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.2.3.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.</span> <span class="toc-text">常用容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.1.</span> <span class="toc-text">string容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.1.1.</span> <span class="toc-text">string容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.1.2.</span> <span class="toc-text">string容器常用操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.2.</span> <span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.2.1.</span> <span class="toc-text">vector容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.2.2.</span> <span class="toc-text">vector容器常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.3.2.3.</span> <span class="toc-text">vector迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">16.3.2.4.</span> <span class="toc-text">vector小案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.3.</span> <span class="toc-text">deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.3.1.</span> <span class="toc-text">deque容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.3.2.</span> <span class="toc-text">deque容器常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">16.3.3.3.</span> <span class="toc-text">deque小案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.4.</span> <span class="toc-text">stack容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.4.1.</span> <span class="toc-text">stack容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.4.2.</span> <span class="toc-text">stack容器常用操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.5.</span> <span class="toc-text">queue容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.5.1.</span> <span class="toc-text">queue容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.5.2.</span> <span class="toc-text">queue容器常用操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.6.</span> <span class="toc-text">list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.6.1.</span> <span class="toc-text">list容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.3.6.2.</span> <span class="toc-text">list的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.6.3.</span> <span class="toc-text">list容器常用操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-multiset%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.7.</span> <span class="toc-text">set&#x2F;multiset容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.7.1.</span> <span class="toc-text">set&#x2F;multiset容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.7.2.</span> <span class="toc-text">set&#x2F;multiset容器常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%BB%84"><span class="toc-number">16.3.7.3.</span> <span class="toc-text">对组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-multimap%E5%AE%B9%E5%99%A8"><span class="toc-number">16.3.8.</span> <span class="toc-text">map&#x2F;multimap容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">16.3.8.1.</span> <span class="toc-text">map&#x2F;multimap基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.8.2.</span> <span class="toc-text">map&#x2F;multimap常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multimap%E6%A1%88%E4%BE%8B"><span class="toc-number">16.3.8.3.</span> <span class="toc-text">multimap案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-1"><span class="toc-number">16.4.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.4.1.</span> <span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%93%E8%AF%AD"><span class="toc-number">16.4.2.</span> <span class="toc-text">谓语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.4.3.</span> <span class="toc-text">内建函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">16.4.3.1.</span> <span class="toc-text">函数对象适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">16.4.4.</span> <span class="toc-text">算法概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.5.</span> <span class="toc-text">常用遍历算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for-each%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.5.1.</span> <span class="toc-text">for_each遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.5.2.</span> <span class="toc-text">transform算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.6.</span> <span class="toc-text">常用查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.7.</span> <span class="toc-text">常用排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.8.</span> <span class="toc-text">常用拷贝和替换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%95%B0%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.9.</span> <span class="toc-text">常用算数生成算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-number">16.4.10.</span> <span class="toc-text">常用集合算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/04/c++/" title="C/C++程序设计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageCover/c++.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C/C++程序设计"/></a><div class="content"><a class="title" href="/2024/10/04/c++/" title="C/C++程序设计">C/C++程序设计</a><time datetime="2024-10-04T15:46:02.000Z" title="发表于 2024-10-04 23:46:02">2024-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/01/anzhiyu%E4%B8%BB%E9%A2%98%E6%A0%87%E7%AD%BE/" title="安知鱼主题标签 Tag Plugins"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageCover/Markdown.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安知鱼主题标签 Tag Plugins"/></a><div class="content"><a class="title" href="/2023/06/01/anzhiyu%E4%B8%BB%E9%A2%98%E6%A0%87%E7%AD%BE/" title="安知鱼主题标签 Tag Plugins">安知鱼主题标签 Tag Plugins</a><time datetime="2023-06-01T07:55:44.000Z" title="发表于 2023-06-01 15:55:44">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/11/CSS/" title="CSS"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageCover/CSS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS"/></a><div class="content"><a class="title" href="/2022/11/11/CSS/" title="CSS">CSS</a><time datetime="2022-11-11T02:45:00.000Z" title="发表于 2022-11-11 10:45:00">2022-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="微信小程序"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/src/images/pageCover/wechat.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微信小程序"/></a><div class="content"><a class="title" href="/2022/11/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="微信小程序">微信小程序</a><time datetime="2022-11-10T10:10:00.000Z" title="发表于 2022-11-10 18:10:00">2022-11-10</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:anzhiyu-c@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/6378063631" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/profile.php?id=100092208016287&amp;sk=about" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="src/images/avatar.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/372204786" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://v.douyin.com/DwCpMEy/" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Zian" target="_blank">Zian</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.0.15/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://image.anheyu.com" title="图床">图床</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="湘ICP备-xxxxxxx号">湘ICP备-xxxxxxx号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.zianyoyo.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.xtone.club/" title="归一"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="归一"/><span class="back-menu-item-text">归一</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/favicon.ico" title="安知鱼主题官方文档"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼主题官方文档"/><span class="back-menu-item-text">安知鱼主题官方文档</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-C/" style="font-size: 0.88rem;">C/C++<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/JS/" style="font-size: 0.88rem;">JS<sup>1</sup></a><a href="/tags/Tag-Plugins/" style="font-size: 0.88rem;">Tag Plugins<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.10",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Zian 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://www.zian-twikoo.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://www.zian-twikoo.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://www.zian-twikoo.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>